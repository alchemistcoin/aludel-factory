{
  "address": "0xb63E52F39CCeca01db3e37d733e44Fe7e8aD70cd",
  "abi": [
    {
      "inputs": [],
      "name": "FloorAboveCeiling",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "InvalidAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAmountArray",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidDuration",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidVault",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MaxBonusTokensReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MaxStakesReached",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoAmountStaked",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoAmountUnstaked",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoStakes",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Powered_IsShutdown",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Powered_NotOffline",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Powered_NotOnline",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Powered_NotShutdown",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Powered_NotStarted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ScalingTimeIsZero",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "VaultAlreadyRegistered",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "VaultFactoryNotRegistered",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "rewardPool",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "powerSwitch",
          "type": "address"
        }
      ],
      "name": "AludelCreated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "duration",
          "type": "uint256"
        }
      ],
      "name": "AludelFunded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "BonusTokenRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "RewardClaimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Staked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "Unstaked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "name": "VaultFactoryRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "name": "VaultFactoryRemoved",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BASE_SHARES_PER_WEI",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_REWARD_TOKENS",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_STAKES_PER_VAULT",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "remainingRewards",
          "type": "uint256"
        }
      ],
      "name": "_claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "unlockedRewards",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "stakeDuration",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalStakeUnits",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "floor",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "ceiling",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "time",
              "type": "uint256"
            }
          ],
          "internalType": "struct IAludelV3.RewardScaling",
          "name": "rewardScaling",
          "type": "tuple"
        }
      ],
      "name": "calculateReward",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "start",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "end",
          "type": "uint256"
        }
      ],
      "name": "calculateStakeUnits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "stakeUnits",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "amount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            }
          ],
          "internalType": "struct IAludelV3.StakeData[]",
          "name": "stakes",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "calculateTotalStakeUnits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalStakeUnits",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "duration",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "start",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "shares",
              "type": "uint256"
            }
          ],
          "internalType": "struct IAludelV3.RewardSchedule[]",
          "name": "rewardSchedules",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "rewardBalance",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "sharesOutstanding",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "calculateUnlockedRewards",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "unlockedRewards",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "duration",
          "type": "uint256"
        }
      ],
      "name": "fund",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getAludelData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "stakingToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "rewardToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "rewardPool",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "floor",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "ceiling",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "time",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IAludelV3.RewardScaling",
              "name": "rewardScaling",
              "type": "tuple"
            },
            {
              "internalType": "uint256",
              "name": "rewardSharesOutstanding",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalStake",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalStakeUnits",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lastUpdate",
              "type": "uint256"
            },
            {
              "internalType": "contract IAludelHooks",
              "name": "hookContract",
              "type": "address"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "duration",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "start",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "shares",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IAludelV3.RewardSchedule[]",
              "name": "rewardSchedules",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct IAludelV3.AludelData",
          "name": "aludel",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getBonusTokenAtIndex",
      "outputs": [
        {
          "internalType": "address",
          "name": "bonusToken",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getBonusTokenSetLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCurrentTotalStakeUnits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalStakeUnits",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "getFutureTotalStakeUnits",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "totalStakeUnits",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPowerController",
      "outputs": [
        {
          "internalType": "address",
          "name": "controller",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPowerSwitch",
      "outputs": [
        {
          "internalType": "address",
          "name": "powerSwitch",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault",
          "type": "address"
        }
      ],
      "name": "getVaultData",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "totalStake",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "timestamp",
                  "type": "uint256"
                }
              ],
              "internalType": "struct IAludelV3.StakeData[]",
              "name": "stakes",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct IAludelV3.VaultData",
          "name": "vaultData",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getVaultFactoryAtIndex",
      "outputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getVaultFactorySetLength",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "length",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "startTime",
          "type": "uint64"
        },
        {
          "internalType": "address",
          "name": "ownerAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "feeRecipient",
          "type": "address"
        },
        {
          "internalType": "uint16",
          "name": "feeBps",
          "type": "uint16"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initializeLock",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isOffline",
      "outputs": [
        {
          "internalType": "bool",
          "name": "status",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isOnline",
      "outputs": [
        {
          "internalType": "bool",
          "name": "status",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isShutdown",
      "outputs": [
        {
          "internalType": "bool",
          "name": "status",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isStarted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "status",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "isValidAddress",
      "outputs": [
        {
          "internalType": "bool",
          "name": "validity",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "target",
          "type": "address"
        }
      ],
      "name": "isValidVault",
      "outputs": [
        {
          "internalType": "bool",
          "name": "validity",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rageQuit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "bonusToken",
          "type": "address"
        }
      ],
      "name": "registerBonusToken",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "name": "registerVaultFactory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "factory",
          "type": "address"
        }
      ],
      "name": "removeVaultFactory",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "rescueTokensFromRewardPool",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "permission",
          "type": "bytes"
        }
      ],
      "name": "stake",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "vault",
          "type": "address"
        },
        {
          "internalType": "uint256[]",
          "name": "indices",
          "type": "uint256[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "internalType": "bytes",
          "name": "permission",
          "type": "bytes"
        }
      ],
      "name": "unstakeAndClaim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x5ab1da7b4ac77cb5325f72d5f532d1f49c8b6f6148b6bd402c8a5018544b4d49",
  "receipt": {
    "to": null,
    "from": "0x844eAb6D943B1Db987786a2469D7A0bCCd38ddDc",
    "contractAddress": "0xb63E52F39CCeca01db3e37d733e44Fe7e8aD70cd",
    "transactionIndex": 5,
    "gasUsed": "2532138",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000008000000000008000000000008000000000000000000000000000080000800021000000000000000100000000000000000000020000000000000000000800000000000000000080000000000000400000000000000000001000000000000000000000000000000000000000000000200000080000000000080000000000000000000000000000000000000000004000000000000000000001000000008100000000000000000000100000000020000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0xf11de64b235192a8e524e972b28911f1faead04af93d72e1e38a657776c5b300",
    "transactionHash": "0x5ab1da7b4ac77cb5325f72d5f532d1f49c8b6f6148b6bd402c8a5018544b4d49",
    "logs": [
      {
        "transactionIndex": 5,
        "blockNumber": 30743743,
        "transactionHash": "0x5ab1da7b4ac77cb5325f72d5f532d1f49c8b6f6148b6bd402c8a5018544b4d49",
        "address": "0xb63E52F39CCeca01db3e37d733e44Fe7e8aD70cd",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000844eab6d943b1db987786a2469d7a0bccd38dddc"
        ],
        "data": "0x",
        "logIndex": 22,
        "blockHash": "0xf11de64b235192a8e524e972b28911f1faead04af93d72e1e38a657776c5b300"
      },
      {
        "transactionIndex": 5,
        "blockNumber": 30743743,
        "transactionHash": "0x5ab1da7b4ac77cb5325f72d5f532d1f49c8b6f6148b6bd402c8a5018544b4d49",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000844eab6d943b1db987786a2469d7a0bccd38dddc",
          "0x0000000000000000000000003a22c8bc68e98b0faf40f349dd2b2890fae01484"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000d7e72fb04b6000000000000000000000000000000000000000000000000000dec95b707ecb63d0000000000000000000000000000000000000000000001b6c923f712180c9bc70000000000000000000000000000000000000000000000000ddf17440ce8003d0000000000000000000000000000000000000000000001b6c9317585131151c7",
        "logIndex": 23,
        "blockHash": "0xf11de64b235192a8e524e972b28911f1faead04af93d72e1e38a657776c5b300"
      }
    ],
    "blockNumber": 30743743,
    "cumulativeGasUsed": "6858836",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "8c6e9d94b858831aead399fbbcaddb3c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"FloorAboveCeiling\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmountArray\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDuration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidVault\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxBonusTokensReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MaxStakesReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAmountStaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoAmountUnstaked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoStakes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Powered_IsShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Powered_NotOffline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Powered_NotOnline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Powered_NotShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Powered_NotStarted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ScalingTimeIsZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultAlreadyRegistered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFactoryNotRegistered\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"rewardPool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"powerSwitch\",\"type\":\"address\"}],\"name\":\"AludelCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AludelFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"BonusTokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"VaultFactoryRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"VaultFactoryRemoved\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE_SHARES_PER_WEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REWARD_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_STAKES_PER_VAULT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingRewards\",\"type\":\"uint256\"}],\"name\":\"_claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockedRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeUnits\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct IAludelV3.RewardScaling\",\"name\":\"rewardScaling\",\"type\":\"tuple\"}],\"name\":\"calculateReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"calculateStakeUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IAludelV3.StakeData[]\",\"name\":\"stakes\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateTotalStakeUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakeUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"internalType\":\"struct IAludelV3.RewardSchedule[]\",\"name\":\"rewardSchedules\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"rewardBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sharesOutstanding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateUnlockedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unlockedRewards\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"fund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAludelData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardPool\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"floor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ceiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"internalType\":\"struct IAludelV3.RewardScaling\",\"name\":\"rewardScaling\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"rewardSharesOutstanding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalStakeUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"contract IAludelHooks\",\"name\":\"hookContract\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"internalType\":\"struct IAludelV3.RewardSchedule[]\",\"name\":\"rewardSchedules\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IAludelV3.AludelData\",\"name\":\"aludel\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBonusTokenAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bonusToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBonusTokenSetLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTotalStakeUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakeUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getFutureTotalStakeUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalStakeUnits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPowerController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPowerSwitch\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"powerSwitch\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"getVaultData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalStake\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct IAludelV3.StakeData[]\",\"name\":\"stakes\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IAludelV3.VaultData\",\"name\":\"vaultData\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVaultFactoryAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultFactorySetLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"startTime\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"ownerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"feeBps\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializeLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOffline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOnline\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isValidAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validity\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"isValidVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"validity\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rageQuit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"bonusToken\",\"type\":\"address\"}],\"name\":\"registerBonusToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"registerVaultFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"removeVaultFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"rescueTokensFromRewardPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permission\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"indices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"permission\",\"type\":\"bytes\"}],\"name\":\"unstakeAndClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"fund(uint256,uint256)\":{\"params\":{\"amount\":\"uint256 Amount of reward tokens to deposit\",\"duration\":\"uint256 Duration over which to linearly unlock rewards\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"rageQuit()\":{\"details\":\"This function should never revert when correctly called by the vault.      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to      place an upper bound on the for loop in calculateTotalStakeUnits(). access control: only callable by the vault directly state machine:   - when vault exists on this Aludel   - when active stake from this vault   - any power state state scope:   - decrease _aludel.totalStake   - increase _aludel.lastUpdate   - modify _aludel.totalStakeUnits   - delete _vaults[vault] token transfer: none\"},\"registerBonusToken(address)\":{\"details\":\"use this function to enable distribution of any ERC20 held by the RewardPool contract access control: only admin state machine:   - can be called multiple times   - only online state scope:   - append to _bonusTokenSet token transfer: none\",\"params\":{\"bonusToken\":\"address The address of the bonus token\"}},\"registerVaultFactory(address)\":{\"details\":\"use this function to enable stakes to vaults coming from the specified      factory contract access control: only admin state machine:   - can be called multiple times   - not shutdown state scope:   - append to _vaultFactorySet token transfer: none\",\"params\":{\"factory\":\"address The address of the vault factory\"}},\"removeVaultFactory(address)\":{\"details\":\"use this function to disable new stakes to vaults coming from the specified      factory contract.      note: vaults with existing stakes from this factory are sill able to unstake access control: only admin state machine:   - can be called multiple times   - not shutdown state scope:   - remove from _vaultFactorySet token transfer: none\",\"params\":{\"factory\":\"address The address of the vault factory\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"rescueTokensFromRewardPool(address,address,uint256)\":{\"details\":\"use this function to rescue tokens from RewardPool contract      without distributing to stakers or triggering emergency shutdown access control: only admin state machine:   - can be called multiple times   - only online state scope: none token transfer: transfer requested token from RewardPool to recipient\",\"params\":{\"amount\":\"uint256 The amount of tokens to rescue\",\"recipient\":\"address The address of the recipient\",\"token\":\"address The address of the token to rescue\"}},\"stake(address,uint256,bytes)\":{\"params\":{\"amount\":\"uint256 The amount of staking tokens to stake\",\"permission\":\"bytes The signed lock permission for the universal vault\",\"vault\":\"address The address of the vault to stake from\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"unstakeAndClaim(address,uint256[],uint256[],bytes)\":{\"details\":\"rewards can only be claimed when unstaking, thus reseting the reward multiplier access control: anyone with a valid permission state machine:   - when vault exists on this Aludel   - after stake from vault   - can be called multiple times while sufficient stake remains   - only online state scope:   - decrease _aludel.rewardSharesOutstanding   - decrease _aludel.totalStake   - increase _aludel.lastUpdate   - modify _aludel.totalStakeUnits   - modify _vaults[vault].stakes   - decrease _vaults[vault].totalStake token transfer:   - transfer reward tokens from reward pool to vault   - transfer bonus tokens from reward pool to vault\",\"params\":{\"amounts\":\"uint256 The amount of staking tokens to unstake\",\"indices\":\"uint256 The amount of staking tokens to unstake\",\"permission\":\"bytes The signed lock permission for the universal vault\",\"vault\":\"address The vault to unstake from\"}}},\"title\":\"Aludel\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"fund(uint256,uint256)\":{\"notice\":\"Add funds to the Aludel access control: only admin state machine:   - can be called multiple times   - only online state scope:   - increase _aludel.rewardSharesOutstanding   - append to _aludel.rewardSchedules token transfer: transfer staking tokens from msg.sender to reward pool\"},\"initialize(uint64,address,address,uint16,bytes)\":{\"notice\":\"Initizalize Aludel access control: only proxy constructor state machine: can only be called once state scope: set initialization variables token transfer: none\"},\"rageQuit()\":{\"notice\":\"Exit Aludel without claiming reward\"},\"registerBonusToken(address)\":{\"notice\":\"Register bonus token for distribution\"},\"registerVaultFactory(address)\":{\"notice\":\"Add vault factory to whitelist\"},\"removeVaultFactory(address)\":{\"notice\":\"Remove vault factory from whitelist\"},\"rescueTokensFromRewardPool(address,address,uint256)\":{\"notice\":\"Rescue tokens from RewardPool\"},\"stake(address,uint256,bytes)\":{\"notice\":\"Stake tokens access control: anyone with a valid permission state machine:   - can be called multiple times   - only online   - when vault exists on this Aludel state scope:   - append to _vaults[vault].stakes   - increase _vaults[vault].totalStake   - increase _aludel.totalStake   - increase _aludel.totalStakeUnits   - increase _aludel.lastUpdate token transfer: transfer staking tokens from msg.sender to vault\"},\"unstakeAndClaim(address,uint256[],uint256[],bytes)\":{\"notice\":\"Unstake staking tokens and claim reward\"}},\"notice\":\"Reward distribution contract with time multiplier Access Control - Power controller:     Can power off / shutdown the Aludel     Can withdraw rewards from reward pool once shutdown - Aludel admin:     Can add funds to the Aludel, register bonus tokens, and whitelist new vault factories     Is a subset of proxy owner permissions - User:     Can deposit / withdraw / ragequit Aludel State Machine - Online:     Aludel is operating normally, all functions are enabled - Offline:     Aludel is temporarely disabled for maintenance     User deposits and withdrawls are disabled, ragequit remains enabled     Users can withdraw their stake through rageQuit() but forego their pending reward     Should only be used when downtime required for an upgrade - Shutdown:     Aludel is permanently disabled     All functions are disabled with the exception of ragequit     Users can withdraw their stake through rageQuit()     Power controller can withdraw from the reward pool     Should only be used if Proxy Owner role is compromized\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/contracts/aludel/AludelV3.sol\":\"AludelV3\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/access/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\",\"keccak256\":\"0x24e0364e503a9bbde94c715d26573a76f14cd2a202d45f96f52134ab806b67b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !Address.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb68c2016cd41840646addd6f79f17f80f42a6279acb0cd4d9d85cab6e8d9b777\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x0d4de01fe5360c38b4ad2b0822a12722958428f5138a7ff47c1720eb6fa52bba\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2ccf9d2313a313d41a791505f2b5abfdc62191b5d4334f7f7a82691c088a1c87\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0xe2e337e6dde9ef6b680e07338c493ebea1b5fd09b43424112868e9cc1706bca7\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0x3c07f43e60e099b3b157243b3152722e73b80eeb7985c2cd73712828d7f7da29\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0f633a0223d9a1dcccfcf38a64c9de0874dfcbfac0c6941ccf074d63a2ce0e1e\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xacac2065b3ed1facff1163435890d4a6bcdc474e857e8e2c91ae5fb50418f723\",\"license\":\"MIT\"},\"@uniswap/lib/contracts/libraries/TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.6.0;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeApprove: approve failed'\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::safeTransfer: transfer failed'\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            'TransferHelper::transferFrom: transferFrom failed'\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\\n    }\\n}\\n\",\"keccak256\":\"0xaff99b54915f57e2a4e71b8d15afd4ee425410e5a6f45c07517ae1beb806f8bd\",\"license\":\"GPL-3.0-or-later\"},\"alchemist/contracts/aludel/Aludel.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\npragma abicoder v2;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\nimport {IFactory} from \\\"../factory/IFactory.sol\\\";\\nimport {IInstanceRegistry} from \\\"../factory/InstanceRegistry.sol\\\";\\nimport {IUniversalVault} from \\\"../crucible/Crucible.sol\\\";\\nimport {IRewardPool} from \\\"./RewardPool.sol\\\";\\nimport {Powered} from \\\"./Powered.sol\\\";\\n\\ninterface IRageQuit {\\n    function rageQuit() external;\\n}\\n\\ninterface IAludel is IRageQuit {\\n    /* admin events */\\n\\n    event AludelCreated(address rewardPool, address powerSwitch);\\n    event AludelFunded(uint256 amount, uint256 duration);\\n    event BonusTokenRegistered(address token);\\n    event VaultFactoryRegistered(address factory);\\n    event VaultFactoryRemoved(address factory);\\n\\n    /* user events */\\n\\n    event Staked(address vault, uint256 amount);\\n    event Unstaked(address vault, uint256 amount);\\n    event RewardClaimed(address vault, address token, uint256 amount);\\n\\n    /* data types */\\n\\n    struct AludelData {\\n        address stakingToken;\\n        address rewardToken;\\n        address rewardPool;\\n        RewardScaling rewardScaling;\\n        uint256 rewardSharesOutstanding;\\n        uint256 totalStake;\\n        uint256 totalStakeUnits;\\n        uint256 lastUpdate;\\n        RewardSchedule[] rewardSchedules;\\n    }\\n\\n    struct RewardSchedule {\\n        uint256 duration;\\n        uint256 start;\\n        uint256 shares;\\n    }\\n\\n    struct VaultData {\\n        uint256 totalStake;\\n        StakeData[] stakes;\\n    }\\n\\n    struct StakeData {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    struct RewardScaling {\\n        uint256 floor;\\n        uint256 ceiling;\\n        uint256 time;\\n    }\\n\\n    struct RewardOutput {\\n        uint256 lastStakeAmount;\\n        uint256 newStakesCount;\\n        uint256 reward;\\n        uint256 newTotalStakeUnits;\\n    }\\n\\n    /* user functions */\\n\\n    function stake(\\n        address vault,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external;\\n\\n    function unstakeAndClaim(\\n        address vault,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external;\\n\\n    /* admin functions */\\n\\n    function fund(uint256 amount, uint256 duration) external;\\n    \\n    function registerVaultFactory(address factory) external;\\n    \\n    function removeVaultFactory(address factory) external;\\n    \\n    function registerBonusToken(address bonusToken) external;\\n\\n    function rescueTokensFromRewardPool(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    ) external;\\n\\n    /* getter functions */\\n\\n    function getAludelData() external view returns (AludelData memory aludel);\\n\\n    function getBonusTokenSetLength() external view returns (uint256 length);\\n\\n    function getBonusTokenAtIndex(uint256 index) external view returns (address bonusToken);\\n\\n    function getVaultFactorySetLength() external view returns (uint256 length);\\n\\n    function getVaultFactoryAtIndex(uint256 index) external view returns (address factory);\\n\\n    function getVaultData(address vault) external view returns (VaultData memory vaultData);\\n\\n    function isValidAddress(address target) external view returns (bool validity);\\n\\n    function isValidVault(address target) external view returns (bool validity);\\n\\n    function getCurrentUnlockedRewards() external view returns (uint256 unlockedRewards);\\n\\n    function getFutureUnlockedRewards(uint256 timestamp)\\n        external\\n        view\\n        returns (uint256 unlockedRewards);\\n\\n    function getCurrentVaultReward(address vault) external view returns (uint256 reward);\\n\\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\\n        external\\n        view\\n        returns (uint256 reward);\\n\\n    function getFutureVaultReward(address vault, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256 reward);\\n\\n    function getFutureStakeReward(\\n        address vault,\\n        uint256 stakeAmount,\\n        uint256 timestamp\\n    ) external view returns (uint256 reward);\\n\\n    function getCurrentVaultStakeUnits(address vault) external view returns (uint256 stakeUnits);\\n\\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\\n        external\\n        view\\n        returns (uint256 stakeUnits);\\n\\n    function getCurrentTotalStakeUnits() external view returns (uint256 totalStakeUnits);\\n\\n    function getFutureTotalStakeUnits(uint256 timestamp)\\n        external\\n        view\\n        returns (uint256 totalStakeUnits);\\n\\n    /* pure functions */\\n\\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\\n        external\\n        pure\\n        returns (uint256 totalStakeUnits);\\n\\n    function calculateStakeUnits(\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end\\n    ) external pure returns (uint256 stakeUnits);\\n\\n    function calculateUnlockedRewards(\\n        RewardSchedule[] memory rewardSchedules,\\n        uint256 rewardBalance,\\n        uint256 sharesOutstanding,\\n        uint256 timestamp\\n    ) external pure returns (uint256 unlockedRewards);\\n\\n    function calculateRewardFromStakes(\\n        StakeData[] memory stakes,\\n        uint256 unstakeAmount,\\n        uint256 unlockedRewards,\\n        uint256 totalStakeUnits,\\n        uint256 timestamp,\\n        RewardScaling memory rewardScaling\\n    ) external pure returns (RewardOutput memory out);\\n\\n    function calculateReward(\\n        uint256 unlockedRewards,\\n        uint256 stakeAmount,\\n        uint256 stakeDuration,\\n        uint256 totalStakeUnits,\\n        RewardScaling memory rewardScaling\\n    ) external pure returns (uint256 reward);\\n}\\n\\n/// @title Aludel\\n/// @notice Reward distribution contract with time multiplier\\n/// Access Control\\n/// - Power controller:\\n///     Can power off / shutdown the Aludel\\n///     Can withdraw rewards from reward pool once shutdown\\n/// - Aludel admin:\\n///     Can add funds to the Aludel, register bonus tokens, and whitelist new vault factories\\n///     Is a subset of proxy owner permissions\\n/// - User:\\n///     Can deposit / withdraw / ragequit\\n/// Aludel State Machine\\n/// - Online:\\n///     Aludel is operating normally, all functions are enabled\\n/// - Offline:\\n///     Aludel is temporarely disabled for maintenance\\n///     User deposits and withdrawls are disabled, ragequit remains enabled\\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\\n///     Should only be used when downtime required for an upgrade\\n/// - Shutdown:\\n///     Aludel is permanently disabled\\n///     All functions are disabled with the exception of ragequit\\n///     Users can withdraw their stake through rageQuit()\\n///     Power controller can withdraw from the reward pool\\n///     Should only be used if Proxy Owner role is compromized\\ncontract Aludel is IAludel, Powered, Ownable {\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /* constants */\\n\\n    // An upper bound on the number of active stakes per vault is required to prevent\\n    // calls to rageQuit() from reverting.\\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\\n    // than the hardcoded limit of 500k gas on the vault.\\n    // This limit is configurable and could be increased in a future deployment.\\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\\n    uint256 public constant MAX_REWARD_TOKENS = 50;\\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\\n\\n    /* storage */\\n\\n    AludelData private _aludel;\\n    mapping(address => VaultData) private _vaults;\\n    EnumerableSet.AddressSet private _bonusTokenSet;\\n    EnumerableSet.AddressSet private _vaultFactorySet;\\n\\n    /* initializer */\\n\\n    /// @notice Initizalize Aludel\\n    /// access control: only proxy constructor\\n    /// state machine: can only be called once\\n    /// state scope: set initialization variables\\n    /// token transfer: none\\n    /// @param ownerAddress address The admin address\\n    /// @param rewardPoolFactory address The factory to use for deploying the RewardPool\\n    /// @param powerSwitchFactory address The factory to use for deploying the PowerSwitch\\n    /// @param stakingToken address The address of the staking token for this Aludel\\n    /// @param rewardToken address The address of the reward token for this Aludel\\n    /// @param rewardScaling RewardScaling The config for reward scaling floor, ceiling, and time\\n    constructor(\\n        address ownerAddress,\\n        address rewardPoolFactory,\\n        address powerSwitchFactory,\\n        address stakingToken,\\n        address rewardToken,\\n        RewardScaling memory rewardScaling\\n    ) {\\n        // the scaling floor must be smaller than ceiling\\n        require(rewardScaling.floor <= rewardScaling.ceiling, \\\"Aludel: floor above ceiling\\\");\\n\\n        // setting rewardScalingTime to 0 would cause divide by zero error\\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\\n        require(rewardScaling.time != 0, \\\"Aludel: scaling time cannot be zero\\\");\\n\\n        // deploy power switch\\n        address powerSwitch = IFactory(powerSwitchFactory).create(abi.encode(ownerAddress));\\n\\n        // deploy reward pool\\n        address rewardPool = IFactory(rewardPoolFactory).create(abi.encode(powerSwitch));\\n\\n        // set internal configs\\n        Ownable.transferOwnership(ownerAddress);\\n        Powered._setPowerSwitch(powerSwitch);\\n\\n        // commit to storage\\n        _aludel.stakingToken = stakingToken;\\n        _aludel.rewardToken = rewardToken;\\n        _aludel.rewardPool = rewardPool;\\n        _aludel.rewardScaling = rewardScaling;\\n\\n        // emit event\\n        emit AludelCreated(rewardPool, powerSwitch);\\n    }\\n\\n    /* getter functions */\\n\\n    function getBonusTokenSetLength() external view override returns (uint256 length) {\\n        return _bonusTokenSet.length();\\n    }\\n\\n    function getBonusTokenAtIndex(uint256 index)\\n        external\\n        view\\n        override\\n        returns (address bonusToken)\\n    {\\n        return _bonusTokenSet.at(index);\\n    }\\n\\n    function getVaultFactorySetLength() external view override returns (uint256 length) {\\n        return _vaultFactorySet.length();\\n    }\\n\\n    function getVaultFactoryAtIndex(uint256 index)\\n        external\\n        view\\n        override\\n        returns (address factory)\\n    {\\n        return _vaultFactorySet.at(index);\\n    }\\n\\n    function isValidVault(address target) public view override returns (bool validity) {\\n        // validate target is created from whitelisted vault factory\\n        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {\\n            if (IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)) {\\n                return true;\\n            }\\n        }\\n        // explicit return\\n        return false;\\n    }\\n\\n    function isValidAddress(address target) public view override returns (bool validity) {\\n        // sanity check target for potential input errors\\n        return\\n            target != address(this) &&\\n            target != address(0) &&\\n            target != _aludel.stakingToken &&\\n            target != _aludel.rewardToken &&\\n            target != _aludel.rewardPool &&\\n            !_bonusTokenSet.contains(target);\\n    }\\n\\n    /* Aludel getters */\\n\\n    function getAludelData() external view override returns (AludelData memory aludel) {\\n        return _aludel;\\n    }\\n\\n    function getCurrentUnlockedRewards() public view override returns (uint256 unlockedRewards) {\\n        // calculate reward available based on state\\n        return getFutureUnlockedRewards(block.timestamp);\\n    }\\n\\n    function getFutureUnlockedRewards(uint256 timestamp)\\n        public\\n        view\\n        override\\n        returns (uint256 unlockedRewards)\\n    {\\n        // get reward amount remaining\\n        uint256 remainingRewards = IERC20(_aludel.rewardToken).balanceOf(_aludel.rewardPool);\\n        // calculate reward available based on state\\n        unlockedRewards = calculateUnlockedRewards(\\n            _aludel.rewardSchedules,\\n            remainingRewards,\\n            _aludel.rewardSharesOutstanding,\\n            timestamp\\n        );\\n        // explicit return\\n        return unlockedRewards;\\n    }\\n\\n    function getCurrentTotalStakeUnits() public view override returns (uint256 totalStakeUnits) {\\n        // calculate new stake units\\n        return getFutureTotalStakeUnits(block.timestamp);\\n    }\\n\\n    function getFutureTotalStakeUnits(uint256 timestamp)\\n        public\\n        view\\n        override\\n        returns (uint256 totalStakeUnits)\\n    {\\n        // return early if no change\\n        if (timestamp == _aludel.lastUpdate) return _aludel.totalStakeUnits;\\n        // calculate new stake units\\n        uint256 newStakeUnits =\\n            calculateStakeUnits(_aludel.totalStake, _aludel.lastUpdate, timestamp);\\n        // add to cached total\\n        totalStakeUnits = _aludel.totalStakeUnits.add(newStakeUnits);\\n        // explicit return\\n        return totalStakeUnits;\\n    }\\n\\n    /* vault getters */\\n\\n    function getVaultData(address vault)\\n        external\\n        view\\n        override\\n        returns (VaultData memory vaultData)\\n    {\\n        return _vaults[vault];\\n    }\\n\\n    function getCurrentVaultReward(address vault) external view override returns (uint256 reward) {\\n        // calculate rewards\\n        return\\n            calculateRewardFromStakes(\\n                _vaults[vault]\\n                    .stakes,\\n                _vaults[vault]\\n                    .totalStake,\\n                getCurrentUnlockedRewards(),\\n                getCurrentTotalStakeUnits(),\\n                block\\n                    .timestamp,\\n                _aludel\\n                    .rewardScaling\\n            )\\n                .reward;\\n    }\\n\\n    function getFutureVaultReward(address vault, uint256 timestamp)\\n        external\\n        view\\n        override\\n        returns (uint256 reward)\\n    {\\n        // calculate rewards\\n        return\\n            calculateRewardFromStakes(\\n                _vaults[vault]\\n                    .stakes,\\n                _vaults[vault]\\n                    .totalStake,\\n                getFutureUnlockedRewards(timestamp),\\n                getFutureTotalStakeUnits(timestamp),\\n                timestamp,\\n                _aludel\\n                    .rewardScaling\\n            )\\n                .reward;\\n    }\\n\\n    function getCurrentStakeReward(address vault, uint256 stakeAmount)\\n        external\\n        view\\n        override\\n        returns (uint256 reward)\\n    {\\n        // calculate rewards\\n        return\\n            calculateRewardFromStakes(\\n                _vaults[vault]\\n                    .stakes,\\n                stakeAmount,\\n                getCurrentUnlockedRewards(),\\n                getCurrentTotalStakeUnits(),\\n                block\\n                    .timestamp,\\n                _aludel\\n                    .rewardScaling\\n            )\\n                .reward;\\n    }\\n\\n    function getFutureStakeReward(\\n        address vault,\\n        uint256 stakeAmount,\\n        uint256 timestamp\\n    ) external view override returns (uint256 reward) {\\n        // calculate rewards\\n        return\\n            calculateRewardFromStakes(\\n                _vaults[vault]\\n                    .stakes,\\n                stakeAmount,\\n                getFutureUnlockedRewards(timestamp),\\n                getFutureTotalStakeUnits(timestamp),\\n                timestamp,\\n                _aludel\\n                    .rewardScaling\\n            )\\n                .reward;\\n    }\\n\\n    function getCurrentVaultStakeUnits(address vault)\\n        public\\n        view\\n        override\\n        returns (uint256 stakeUnits)\\n    {\\n        // calculate stake units\\n        return getFutureVaultStakeUnits(vault, block.timestamp);\\n    }\\n\\n    function getFutureVaultStakeUnits(address vault, uint256 timestamp)\\n        public\\n        view\\n        override\\n        returns (uint256 stakeUnits)\\n    {\\n        // calculate stake units\\n        return calculateTotalStakeUnits(_vaults[vault].stakes, timestamp);\\n    }\\n\\n    /* pure functions */\\n\\n    function calculateTotalStakeUnits(StakeData[] memory stakes, uint256 timestamp)\\n        public\\n        pure\\n        override\\n        returns (uint256 totalStakeUnits)\\n    {\\n        for (uint256 index; index < stakes.length; index++) {\\n            // reference stake\\n            StakeData memory stakeData = stakes[index];\\n            // calculate stake units\\n            uint256 stakeUnits =\\n                calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\\n            // add to running total\\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\\n        }\\n    }\\n\\n    function calculateStakeUnits(\\n        uint256 amount,\\n        uint256 start,\\n        uint256 end\\n    ) public pure override returns (uint256 stakeUnits) {\\n        // calculate duration\\n        uint256 duration = end.sub(start);\\n        // calculate stake units\\n        stakeUnits = duration.mul(amount);\\n        // explicit return\\n        return stakeUnits;\\n    }\\n\\n    function calculateUnlockedRewards(\\n        RewardSchedule[] memory rewardSchedules,\\n        uint256 rewardBalance,\\n        uint256 sharesOutstanding,\\n        uint256 timestamp\\n    ) public pure override returns (uint256 unlockedRewards) {\\n        // return 0 if no registered schedules\\n        if (rewardSchedules.length == 0) {\\n            return 0;\\n        }\\n\\n        // calculate reward shares locked across all reward schedules\\n        uint256 sharesLocked;\\n        for (uint256 index = 0; index < rewardSchedules.length; index++) {\\n            // fetch reward schedule storage reference\\n            RewardSchedule memory schedule = rewardSchedules[index];\\n\\n            // caculate amount of shares available on this schedule\\n            // if (now - start) < duration\\n            //   sharesLocked = shares - (shares * (now - start) / duration)\\n            // else\\n            //   sharesLocked = 0\\n            uint256 currentSharesLocked = 0;\\n            if (timestamp.sub(schedule.start) < schedule.duration) {\\n                currentSharesLocked = schedule.shares.sub(\\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\\n                );\\n            }\\n\\n            // add to running total\\n            sharesLocked = sharesLocked.add(currentSharesLocked);\\n        }\\n\\n        // convert shares to reward\\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\\n        uint256 rewardLocked = sharesLocked.mul(rewardBalance).div(sharesOutstanding);\\n\\n        // calculate amount available\\n        // unlockedRewards = rewardBalance - rewardLocked\\n        unlockedRewards = rewardBalance.sub(rewardLocked);\\n\\n        // explicit return\\n        return unlockedRewards;\\n    }\\n\\n    function calculateRewardFromStakes(\\n        StakeData[] memory stakes,\\n        uint256 unstakeAmount,\\n        uint256 unlockedRewards,\\n        uint256 totalStakeUnits,\\n        uint256 timestamp,\\n        RewardScaling memory rewardScaling\\n    ) public pure override returns (RewardOutput memory out) {\\n        uint256 stakesToDrop = 0;\\n        while (unstakeAmount > 0) {\\n            // fetch vault stake storage reference\\n            StakeData memory lastStake = stakes[stakes.length.sub(stakesToDrop).sub(1)];\\n\\n            // calculate stake duration\\n            uint256 stakeDuration = timestamp.sub(lastStake.timestamp);\\n\\n            uint256 currentAmount;\\n            if (lastStake.amount > unstakeAmount) {\\n                // set current amount to remaining unstake amount\\n                currentAmount = unstakeAmount;\\n                // amount of last stake is reduced\\n                out.lastStakeAmount = lastStake.amount.sub(unstakeAmount);\\n            } else {\\n                // set current amount to amount of last stake\\n                currentAmount = lastStake.amount;\\n                // add to stakes to drop\\n                stakesToDrop += 1;\\n            }\\n\\n            // update remaining unstakeAmount\\n            unstakeAmount = unstakeAmount.sub(currentAmount);\\n\\n            // calculate reward amount\\n            uint256 currentReward =\\n                calculateReward(\\n                    unlockedRewards,\\n                    currentAmount,\\n                    stakeDuration,\\n                    totalStakeUnits,\\n                    rewardScaling\\n                );\\n\\n            // update cumulative reward\\n            out.reward = out.reward.add(currentReward);\\n\\n            // update cached unlockedRewards\\n            unlockedRewards = unlockedRewards.sub(currentReward);\\n\\n            // calculate time weighted stake\\n            uint256 stakeUnits = currentAmount.mul(stakeDuration);\\n\\n            // update cached totalStakeUnits\\n            totalStakeUnits = totalStakeUnits.sub(stakeUnits);\\n        }\\n\\n        // explicit return\\n        return\\n            RewardOutput(\\n                out.lastStakeAmount,\\n                stakes.length.sub(stakesToDrop),\\n                out.reward,\\n                totalStakeUnits\\n            );\\n    }\\n\\n    function calculateReward(\\n        uint256 unlockedRewards,\\n        uint256 stakeAmount,\\n        uint256 stakeDuration,\\n        uint256 totalStakeUnits,\\n        RewardScaling memory rewardScaling\\n    ) public pure override returns (uint256 reward) {\\n        // calculate time weighted stake\\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\\n\\n        // calculate base reward\\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\\n        uint256 baseReward = 0;\\n        if (totalStakeUnits != 0) {\\n            // scale reward according to proportional weight\\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\\n        }\\n\\n        // calculate scaled reward\\n        // if no scaling or scaling period completed\\n        //   reward = baseReward\\n        // else\\n        //   minReward = baseReward * scalingFloor / scalingCeiling\\n        //   bonusReward = baseReward\\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\\n        //                 * duration / scalingTime\\n        //   reward = minReward + bonusReward\\n        if (stakeDuration >= rewardScaling.time || rewardScaling.floor == rewardScaling.ceiling) {\\n            // no reward scaling applied\\n            reward = baseReward;\\n        } else {\\n            // calculate minimum reward using scaling floor\\n            uint256 minReward = baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\\n\\n            // calculate bonus reward with vested portion of scaling factor\\n            uint256 bonusReward =\\n                baseReward\\n                    .mul(stakeDuration)\\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\\n                    .div(rewardScaling.ceiling)\\n                    .div(rewardScaling.time);\\n\\n            // add minimum reward and bonus reward\\n            reward = minReward.add(bonusReward);\\n        }\\n\\n        // explicit return\\n        return reward;\\n    }\\n\\n    /* admin functions */\\n\\n    /// @notice Add funds to the Aludel\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    /// state scope:\\n    ///   - increase _aludel.rewardSharesOutstanding\\n    ///   - append to _aludel.rewardSchedules\\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\\n    /// @param amount uint256 Amount of reward tokens to deposit\\n    /// @param duration uint256 Duration over which to linearly unlock rewards\\n    function fund(uint256 amount, uint256 duration) external override onlyOwner onlyOnline {\\n        // validate duration\\n        require(duration != 0, \\\"Aludel: invalid duration\\\");\\n\\n        // create new reward shares\\n        // if existing rewards on this Aludel\\n        //   mint new shares proportional to % change in rewards remaining\\n        //   newShares = remainingShares * newReward / remainingRewards\\n        // else\\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\\n        //   store as fixed point number with same  of decimals as reward token\\n        uint256 newRewardShares;\\n        if (_aludel.rewardSharesOutstanding > 0) {\\n            uint256 remainingRewards = IERC20(_aludel.rewardToken).balanceOf(_aludel.rewardPool);\\n            newRewardShares = _aludel.rewardSharesOutstanding.mul(amount).div(remainingRewards);\\n        } else {\\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\\n        }\\n\\n        // add reward shares to total\\n        _aludel.rewardSharesOutstanding = _aludel.rewardSharesOutstanding.add(newRewardShares);\\n\\n        // store new reward schedule\\n        _aludel.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\\n\\n        // transfer reward tokens to reward pool\\n        TransferHelper.safeTransferFrom(\\n            _aludel.rewardToken,\\n            msg.sender,\\n            _aludel.rewardPool,\\n            amount\\n        );\\n\\n        // emit event\\n        emit AludelFunded(amount, duration);\\n    }\\n\\n    /// @notice Add vault factory to whitelist\\n    /// @dev use this function to enable stakes to vaults coming from the specified\\n    ///      factory contract\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - not shutdown\\n    /// state scope:\\n    ///   - append to _vaultFactorySet\\n    /// token transfer: none\\n    /// @param factory address The address of the vault factory\\n    function registerVaultFactory(address factory) external override onlyOwner notShutdown {\\n        // add factory to set\\n        require(_vaultFactorySet.add(factory), \\\"Aludel: vault factory already registered\\\");\\n\\n        // emit event\\n        emit VaultFactoryRegistered(factory);\\n    }\\n\\n    /// @notice Remove vault factory from whitelist\\n    /// @dev use this function to disable new stakes to vaults coming from the specified\\n    ///      factory contract.\\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - not shutdown\\n    /// state scope:\\n    ///   - remove from _vaultFactorySet\\n    /// token transfer: none\\n    /// @param factory address The address of the vault factory\\n    function removeVaultFactory(address factory) external override onlyOwner notShutdown {\\n        // remove factory from set\\n        require(_vaultFactorySet.remove(factory), \\\"Aludel: vault factory not registered\\\");\\n\\n        // emit event\\n        emit VaultFactoryRemoved(factory);\\n    }\\n\\n    /// @notice Register bonus token for distribution\\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    /// state scope:\\n    ///   - append to _bonusTokenSet\\n    /// token transfer: none\\n    /// @param bonusToken address The address of the bonus token\\n    function registerBonusToken(address bonusToken) external override onlyOwner onlyOnline {\\n        // verify valid bonus token\\n        _validateAddress(bonusToken);\\n\\n        // verify bonus token count\\n        require(_bonusTokenSet.length() < MAX_REWARD_TOKENS, \\\"Aludel: max bonus tokens reached \\\");\\n\\n        // add token to set\\n        assert(_bonusTokenSet.add(bonusToken));\\n\\n        // emit event\\n        emit BonusTokenRegistered(bonusToken);\\n    }\\n\\n    /// @notice Rescue tokens from RewardPool\\n    /// @dev use this function to rescue tokens from RewardPool contract\\n    ///      without distributing to stakers or triggering emergency shutdown\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    /// state scope: none\\n    /// token transfer: transfer requested token from RewardPool to recipient\\n    /// @param token address The address of the token to rescue\\n    /// @param recipient address The address of the recipient\\n    /// @param amount uint256 The amount of tokens to rescue\\n    function rescueTokensFromRewardPool(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    ) external override onlyOwner onlyOnline {\\n        // verify recipient\\n        _validateAddress(recipient);\\n\\n        // check not attempting to unstake reward token\\n        require(token != _aludel.rewardToken, \\\"Aludel: invalid address\\\");\\n\\n        // check not attempting to wthdraw bonus token\\n        require(!_bonusTokenSet.contains(token), \\\"Aludel: invalid address\\\");\\n\\n        // transfer tokens to recipient\\n        IRewardPool(_aludel.rewardPool).sendERC20(token, recipient, amount);\\n    }\\n\\n    /* user functions */\\n\\n    /// @notice Stake tokens\\n    /// access control: anyone with a valid permission\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    ///   - when vault exists on this Aludel\\n    /// state scope:\\n    ///   - append to _vaults[vault].stakes\\n    ///   - increase _vaults[vault].totalStake\\n    ///   - increase _aludel.totalStake\\n    ///   - increase _aludel.totalStakeUnits\\n    ///   - increase _aludel.lastUpdate\\n    /// token transfer: transfer staking tokens from msg.sender to vault\\n    /// @param vault address The address of the vault to stake from\\n    /// @param amount uint256 The amount of staking tokens to stake\\n    /// @param permission bytes The signed lock permission for the universal vault\\n\\n    function stake(\\n        address vault,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external override onlyOnline {\\n        // verify vault is valid\\n        require(isValidVault(vault), \\\"Aludel: vault is not registered\\\");\\n\\n        // verify non-zero amount\\n        require(amount != 0, \\\"Aludel: no amount staked\\\");\\n\\n        // fetch vault storage reference\\n        VaultData storage vaultData = _vaults[vault];\\n\\n        // verify stakes boundary not reached\\n        require(\\n            vaultData.stakes.length < MAX_STAKES_PER_VAULT,\\n            \\\"Aludel: MAX_STAKES_PER_VAULT reached\\\"\\n        );\\n\\n        // update cached sum of stake units across all vaults\\n        _updateTotalStakeUnits();\\n\\n        // store amount and timestamp\\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\\n\\n        // update cached total vault and Aludel amounts\\n        vaultData.totalStake = vaultData.totalStake.add(amount);\\n        _aludel.totalStake = _aludel.totalStake.add(amount);\\n\\n        // call lock on vault\\n        IUniversalVault(vault).lock(_aludel.stakingToken, amount, permission);\\n\\n        // emit event\\n        emit Staked(vault, amount);\\n    }\\n\\n    /// @notice Unstake staking tokens and claim reward\\n    /// @dev rewards can only be claimed when unstaking, thus reseting the reward multiplier\\n    /// access control: anyone with a valid permission\\n    /// state machine:\\n    ///   - when vault exists on this Aludel\\n    ///   - after stake from vault\\n    ///   - can be called multiple times while sufficient stake remains\\n    ///   - only online\\n    /// state scope:\\n    ///   - decrease _aludel.rewardSharesOutstanding\\n    ///   - decrease _aludel.totalStake\\n    ///   - increase _aludel.lastUpdate\\n    ///   - modify _aludel.totalStakeUnits\\n    ///   - modify _vaults[vault].stakes\\n    ///   - decrease _vaults[vault].totalStake\\n    /// token transfer:\\n    ///   - transfer reward tokens from reward pool to vault\\n    ///   - transfer bonus tokens from reward pool to vault\\n    /// @param vault address The vault to unstake from\\n    /// @param amount uint256 The amount of staking tokens to unstake\\n    /// @param permission bytes The signed lock permission for the universal vault\\n    function unstakeAndClaim(\\n        address vault,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external override onlyOnline {\\n        // fetch vault storage reference\\n        VaultData storage vaultData = _vaults[vault];\\n\\n        // verify non-zero amount\\n        require(amount != 0, \\\"Aludel: no amount unstaked\\\");\\n\\n        // check for sufficient vault stake amount\\n        require(vaultData.totalStake >= amount, \\\"Aludel: insufficient vault stake\\\");\\n\\n        // check for sufficient Aludel stake amount\\n        // if this check fails, there is a bug in stake accounting\\n        assert(_aludel.totalStake >= amount);\\n\\n        // update cached sum of stake units across all vaults\\n        _updateTotalStakeUnits();\\n\\n        // get reward amount remaining\\n        uint256 remainingRewards = IERC20(_aludel.rewardToken).balanceOf(_aludel.rewardPool);\\n\\n        // calculate vested portion of reward pool\\n        uint256 unlockedRewards =\\n            calculateUnlockedRewards(\\n                _aludel.rewardSchedules,\\n                remainingRewards,\\n                _aludel.rewardSharesOutstanding,\\n                block.timestamp\\n            );\\n\\n        // calculate vault time weighted reward with scaling\\n        RewardOutput memory out =\\n            calculateRewardFromStakes(\\n                vaultData.stakes,\\n                amount,\\n                unlockedRewards,\\n                _aludel.totalStakeUnits,\\n                block.timestamp,\\n                _aludel.rewardScaling\\n            );\\n\\n        // update stake data in storage\\n        if (out.newStakesCount == 0) {\\n            // all stakes have been unstaked\\n            delete vaultData.stakes;\\n        } else {\\n            // some stakes have been completely or partially unstaked\\n            // delete fully unstaked stakes\\n            while (vaultData.stakes.length > out.newStakesCount) vaultData.stakes.pop();\\n\\n            // update stake amount when lastStakeAmount is set\\n            if (out.lastStakeAmount > 0) {\\n                // update partially unstaked stake\\n                vaultData.stakes[out.newStakesCount.sub(1)].amount = out.lastStakeAmount;\\n            }\\n        }\\n\\n        // update cached stake totals\\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\\n        _aludel.totalStake = _aludel.totalStake.sub(amount);\\n        _aludel.totalStakeUnits = out.newTotalStakeUnits;\\n\\n        // unlock staking tokens from vault\\n        IUniversalVault(vault).unlock(_aludel.stakingToken, amount, permission);\\n\\n        // emit event\\n        emit Unstaked(vault, amount);\\n\\n        // only perform on non-zero reward\\n        if (out.reward > 0) {\\n            // calculate shares to burn\\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\\n            uint256 sharesToBurn =\\n                _aludel.rewardSharesOutstanding.mul(out.reward).div(remainingRewards);\\n\\n            // burn claimed shares\\n            _aludel.rewardSharesOutstanding = _aludel.rewardSharesOutstanding.sub(sharesToBurn);\\n\\n            // transfer bonus tokens from reward pool to vault\\n            if (_bonusTokenSet.length() > 0) {\\n                for (uint256 index = 0; index < _bonusTokenSet.length(); index++) {\\n                    // fetch bonus token address reference\\n                    address bonusToken = _bonusTokenSet.at(index);\\n\\n                    // calculate bonus token amount\\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\\n                    uint256 bonusAmount =\\n                        IERC20(bonusToken).balanceOf(_aludel.rewardPool).mul(out.reward).div(\\n                            remainingRewards\\n                        );\\n\\n                    // transfer bonus token\\n                    IRewardPool(_aludel.rewardPool).sendERC20(bonusToken, vault, bonusAmount);\\n\\n                    // emit event\\n                    emit RewardClaimed(vault, bonusToken, bonusAmount);\\n                }\\n            }\\n\\n            // transfer reward tokens from reward pool to vault\\n            IRewardPool(_aludel.rewardPool).sendERC20(_aludel.rewardToken, vault, out.reward);\\n\\n            // emit event\\n            emit RewardClaimed(vault, _aludel.rewardToken, out.reward);\\n        }\\n    }\\n\\n    /// @notice Exit Aludel without claiming reward\\n    /// @dev This function should never revert when correctly called by the vault.\\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\\n    /// access control: only callable by the vault directly\\n    /// state machine:\\n    ///   - when vault exists on this Aludel\\n    ///   - when active stake from this vault\\n    ///   - any power state\\n    /// state scope:\\n    ///   - decrease _aludel.totalStake\\n    ///   - increase _aludel.lastUpdate\\n    ///   - modify _aludel.totalStakeUnits\\n    ///   - delete _vaults[vault]\\n    /// token transfer: none\\n    function rageQuit() external override {\\n        // fetch vault storage reference\\n        VaultData storage _vaultData = _vaults[msg.sender];\\n\\n        // revert if no active stakes\\n        require(_vaultData.stakes.length != 0, \\\"Aludel: no stake\\\");\\n\\n        // update cached sum of stake units across all vaults\\n        _updateTotalStakeUnits();\\n\\n        // emit event\\n        emit Unstaked(msg.sender, _vaultData.totalStake);\\n\\n        // update cached totals\\n        _aludel.totalStake = _aludel.totalStake.sub(_vaultData.totalStake);\\n        _aludel.totalStakeUnits = _aludel.totalStakeUnits.sub(\\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\\n        );\\n\\n        // delete stake data\\n        delete _vaults[msg.sender];\\n    }\\n\\n    /* convenience functions */\\n\\n    function _updateTotalStakeUnits() private {\\n        // update cached totalStakeUnits\\n        _aludel.totalStakeUnits = getCurrentTotalStakeUnits();\\n        // update cached lastUpdate\\n        _aludel.lastUpdate = block.timestamp;\\n    }\\n\\n    function _validateAddress(address target) private view {\\n        // sanity check target for potential input errors\\n        require(isValidAddress(target), \\\"Aludel: invalid address\\\");\\n    }\\n\\n    function _truncateStakesArray(StakeData[] memory array, uint256 newLength)\\n        private\\n        pure\\n        returns (StakeData[] memory newArray)\\n    {\\n        newArray = new StakeData[](newLength);\\n        for (uint256 index = 0; index < newLength; index++) {\\n            newArray[index] = array[index];\\n        }\\n        return newArray;\\n    }\\n}\\n\",\"keccak256\":\"0x2fe1af3666ac9f28d58cd5f9323680602231ec99bc5d714691669ee598a27a57\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/aludel/PowerSwitch.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IPowerSwitch {\\n    /* admin events */\\n\\n    event PowerOn();\\n    event PowerOff();\\n    event EmergencyShutdown();\\n\\n    /* data types */\\n\\n    enum State {Online, Offline, Shutdown}\\n\\n    /* admin functions */\\n\\n    function powerOn() external;\\n\\n    function powerOff() external;\\n\\n    function emergencyShutdown() external;\\n\\n    /* view functions */\\n\\n    function isOnline() external view returns (bool status);\\n\\n    function isOffline() external view returns (bool status);\\n\\n    function isShutdown() external view returns (bool status);\\n\\n    function getStatus() external view returns (State status);\\n\\n    function getPowerController() external view returns (address controller);\\n}\\n\\n/// @title PowerSwitch\\n/// @notice Standalone pausing and emergency stop functionality\\ncontract PowerSwitch is IPowerSwitch, Ownable {\\n    /* storage */\\n\\n    IPowerSwitch.State private _status;\\n\\n    /* initializer */\\n\\n    constructor(address owner) {\\n        // sanity check owner\\n        require(owner != address(0), \\\"PowerSwitch: invalid owner\\\");\\n        // transfer ownership\\n        Ownable.transferOwnership(owner);\\n    }\\n\\n    /* admin functions */\\n\\n    /// @notice Turn Power On\\n    /// access control: only admin\\n    /// state machine: only when offline\\n    /// state scope: only modify _status\\n    /// token transfer: none\\n    function powerOn() external override onlyOwner {\\n        require(_status == IPowerSwitch.State.Offline, \\\"PowerSwitch: cannot power on\\\");\\n        _status = IPowerSwitch.State.Online;\\n        emit PowerOn();\\n    }\\n\\n    /// @notice Turn Power Off\\n    /// access control: only admin\\n    /// state machine: only when online\\n    /// state scope: only modify _status\\n    /// token transfer: none\\n    function powerOff() external override onlyOwner {\\n        require(_status == IPowerSwitch.State.Online, \\\"PowerSwitch: cannot power off\\\");\\n        _status = IPowerSwitch.State.Offline;\\n        emit PowerOff();\\n    }\\n\\n    /// @notice Shutdown Permanently\\n    /// access control: only admin\\n    /// state machine:\\n    /// - when online or offline\\n    /// - can only be called once\\n    /// state scope: only modify _status\\n    /// token transfer: none\\n    function emergencyShutdown() external override onlyOwner {\\n        require(_status != IPowerSwitch.State.Shutdown, \\\"PowerSwitch: cannot shutdown\\\");\\n        _status = IPowerSwitch.State.Shutdown;\\n        emit EmergencyShutdown();\\n    }\\n\\n    /* getter functions */\\n\\n    function isOnline() external view override returns (bool status) {\\n        return _status == State.Online;\\n    }\\n\\n    function isOffline() external view override returns (bool status) {\\n        return _status == State.Offline;\\n    }\\n\\n    function isShutdown() external view override returns (bool status) {\\n        return _status == State.Shutdown;\\n    }\\n\\n    function getStatus() external view override returns (IPowerSwitch.State status) {\\n        return _status;\\n    }\\n\\n    function getPowerController() external view override returns (address controller) {\\n        return Ownable.owner();\\n    }\\n}\\n\",\"keccak256\":\"0xc7a5fc5aafcc4d597205bbe089b729e024348679ebbc060848033d3aa25507f4\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/aludel/Powered.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {IPowerSwitch} from \\\"./PowerSwitch.sol\\\";\\n\\ninterface IPowered {\\n    function isOnline() external view returns (bool status);\\n\\n    function isOffline() external view returns (bool status);\\n\\n    function isShutdown() external view returns (bool status);\\n\\n    function getPowerSwitch() external view returns (address powerSwitch);\\n\\n    function getPowerController() external view returns (address controller);\\n}\\n\\n/// @title Powered\\n/// @notice Helper for calling external PowerSwitch\\ncontract Powered is IPowered {\\n    /* storage */\\n\\n    address private _powerSwitch;\\n\\n    /* modifiers */\\n\\n    modifier onlyOnline() {\\n        _onlyOnline();\\n        _;\\n    }\\n\\n    modifier onlyOffline() {\\n        _onlyOffline();\\n        _;\\n    }\\n\\n    modifier notShutdown() {\\n        _notShutdown();\\n        _;\\n    }\\n\\n    modifier onlyShutdown() {\\n        _onlyShutdown();\\n        _;\\n    }\\n\\n    /* initializer */\\n\\n    function _setPowerSwitch(address powerSwitch) internal {\\n        _powerSwitch = powerSwitch;\\n    }\\n\\n    /* getter functions */\\n\\n    function isOnline() public view override returns (bool status) {\\n        return IPowerSwitch(_powerSwitch).isOnline();\\n    }\\n\\n    function isOffline() public view override returns (bool status) {\\n        return IPowerSwitch(_powerSwitch).isOffline();\\n    }\\n\\n    function isShutdown() public view override returns (bool status) {\\n        return IPowerSwitch(_powerSwitch).isShutdown();\\n    }\\n\\n    function getPowerSwitch() public view override returns (address powerSwitch) {\\n        return _powerSwitch;\\n    }\\n\\n    function getPowerController() public view override returns (address controller) {\\n        return IPowerSwitch(_powerSwitch).getPowerController();\\n    }\\n\\n    /* convenience functions */\\n\\n    function _onlyOnline() private view {\\n        require(isOnline(), \\\"Powered: is not online\\\");\\n    }\\n\\n    function _onlyOffline() private view {\\n        require(isOffline(), \\\"Powered: is not offline\\\");\\n    }\\n\\n    function _notShutdown() private view {\\n        require(!isShutdown(), \\\"Powered: is shutdown\\\");\\n    }\\n\\n    function _onlyShutdown() private view {\\n        require(isShutdown(), \\\"Powered: is not shutdown\\\");\\n    }\\n}\\n\",\"keccak256\":\"0xc1a176b19e70c0bd907ed58b97038e49838c73a6e150b9fece663cd8c61b0f77\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/aludel/RewardPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\nimport {Powered} from \\\"./Powered.sol\\\";\\n\\ninterface IRewardPool {\\n    function sendERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function rescueERC20(address[] calldata tokens, address recipient) external;\\n}\\n\\n/// @title Reward Pool\\n/// @notice Vault for isolated storage of reward tokens\\ncontract RewardPool is IRewardPool, Powered, Ownable {\\n    /* initializer */\\n\\n    constructor(address powerSwitch) {\\n        Powered._setPowerSwitch(powerSwitch);\\n    }\\n\\n    /* user functions */\\n\\n    /// @notice Send an ERC20 token\\n    /// access control: only owner\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    /// state scope: none\\n    /// token transfer: transfer tokens from self to recipient\\n    /// @param token address The token to send\\n    /// @param to address The recipient to send to\\n    /// @param value uint256 Amount of tokens to send\\n    function sendERC20(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) external override onlyOwner onlyOnline {\\n        TransferHelper.safeTransfer(token, to, value);\\n    }\\n\\n    /* emergency functions */\\n\\n    /// @notice Rescue multiple ERC20 tokens\\n    /// access control: only power controller\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only shutdown\\n    /// state scope: none\\n    /// token transfer: transfer tokens from self to recipient\\n    /// @param tokens address[] The tokens to rescue\\n    /// @param recipient address The recipient to rescue to\\n    function rescueERC20(address[] calldata tokens, address recipient)\\n        external\\n        override\\n        onlyShutdown\\n    {\\n        // only callable by controller\\n        require(\\n            msg.sender == Powered.getPowerController(),\\n            \\\"RewardPool: only controller can withdraw after shutdown\\\"\\n        );\\n\\n        // assert recipient is defined\\n        require(recipient != address(0), \\\"RewardPool: recipient not defined\\\");\\n\\n        // transfer tokens\\n        for (uint256 index = 0; index < tokens.length; index++) {\\n            // get token\\n            address token = tokens[index];\\n            // get balance\\n            uint256 balance = IERC20(token).balanceOf(address(this));\\n            // transfer token\\n            TransferHelper.safeTransfer(token, recipient, balance);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x62e1a6ebee0281fd8f6400a79a5292450a98681d195c2948d9a8e626d41b9304\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/crucible/Crucible.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\npragma abicoder v2;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Initializable} from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\nimport {EIP712} from \\\"./EIP712.sol\\\";\\nimport {ERC1271} from \\\"./ERC1271.sol\\\";\\nimport {OwnableERC721} from \\\"./OwnableERC721.sol\\\";\\nimport {IRageQuit} from \\\"../aludel/Aludel.sol\\\";\\n\\ninterface IUniversalVault {\\n    /* user events */\\n\\n    event Locked(address delegate, address token, uint256 amount);\\n    event Unlocked(address delegate, address token, uint256 amount);\\n    event RageQuit(address delegate, address token, bool notified, string reason);\\n\\n    /* data types */\\n\\n    struct LockData {\\n        address delegate;\\n        address token;\\n        uint256 balance;\\n    }\\n\\n    /* initialize function */\\n\\n    function initialize() external;\\n\\n    /* user functions */\\n\\n    function lock(\\n        address token,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external;\\n\\n    function unlock(\\n        address token,\\n        uint256 amount,\\n        bytes calldata permission\\n    ) external;\\n\\n    function rageQuit(address delegate, address token)\\n        external\\n        returns (bool notified, string memory error);\\n\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function transferETH(address to, uint256 amount) external payable;\\n\\n    /* pure functions */\\n\\n    function calculateLockID(address delegate, address token)\\n        external\\n        pure\\n        returns (bytes32 lockID);\\n\\n    /* getter functions */\\n\\n    function getPermissionHash(\\n        bytes32 eip712TypeHash,\\n        address delegate,\\n        address token,\\n        uint256 amount,\\n        uint256 nonce\\n    ) external view returns (bytes32 permissionHash);\\n\\n    function getNonce() external view returns (uint256 nonce);\\n\\n    function owner() external view returns (address ownerAddress);\\n\\n    function getLockSetCount() external view returns (uint256 count);\\n\\n    function getLockAt(uint256 index) external view returns (LockData memory lockData);\\n\\n    function getBalanceDelegated(address token, address delegate)\\n        external\\n        view\\n        returns (uint256 balance);\\n\\n    function getBalanceLocked(address token) external view returns (uint256 balance);\\n\\n    function checkBalances() external view returns (bool validity);\\n}\\n\\n/// @title Crucible\\n/// @notice Vault for isolated storage of staking tokens\\n/// @dev Warning: not compatible with rebasing tokens\\ncontract Crucible is\\n    IUniversalVault,\\n    EIP712(\\\"UniversalVault\\\", \\\"1.0.0\\\"),\\n    ERC1271,\\n    OwnableERC721,\\n    Initializable\\n{\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using Address for address payable;\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    /* constant */\\n\\n    // Hardcoding a gas limit for rageQuit() is required to prevent gas DOS attacks\\n    // the gas requirement cannot be determined at runtime by querying the delegate\\n    // as it could potentially be manipulated by a malicious delegate who could force\\n    // the calls to revert.\\n    // The gas limit could alternatively be set upon vault initialization or creation\\n    // of a lock, but the gas consumption trade-offs are not favorable.\\n    // Ultimately, to avoid a need for fixed gas limits, the EVM would need to provide\\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\\n    uint256 public constant RAGEQUIT_GAS = 500000;\\n    bytes32 public constant LOCK_TYPEHASH =\\n        keccak256(\\\"Lock(address delegate,address token,uint256 amount,uint256 nonce)\\\");\\n    bytes32 public constant UNLOCK_TYPEHASH =\\n        keccak256(\\\"Unlock(address delegate,address token,uint256 amount,uint256 nonce)\\\");\\n\\n    /* storage */\\n\\n    uint256 private _nonce;\\n    mapping(bytes32 => LockData) private _locks;\\n    EnumerableSet.Bytes32Set private _lockSet;\\n\\n    /* initialization function */\\n\\n    function initializeLock() external initializer {}\\n\\n    function initialize() external override initializer {\\n        OwnableERC721._setNFT(msg.sender);\\n    }\\n\\n    /* ether receive */\\n\\n    receive() external payable {}\\n\\n    /* internal overrides */\\n\\n    function _getOwner() internal view override(ERC1271) returns (address ownerAddress) {\\n        return OwnableERC721.owner();\\n    }\\n\\n    /* pure functions */\\n\\n    function calculateLockID(address delegate, address token)\\n        public\\n        pure\\n        override\\n        returns (bytes32 lockID)\\n    {\\n        return keccak256(abi.encodePacked(delegate, token));\\n    }\\n\\n    /* getter functions */\\n\\n    function getPermissionHash(\\n        bytes32 eip712TypeHash,\\n        address delegate,\\n        address token,\\n        uint256 amount,\\n        uint256 nonce\\n    ) public view override returns (bytes32 permissionHash) {\\n        return\\n            EIP712._hashTypedDataV4(\\n                keccak256(abi.encode(eip712TypeHash, delegate, token, amount, nonce))\\n            );\\n    }\\n\\n    function getNonce() external view override returns (uint256 nonce) {\\n        return _nonce;\\n    }\\n\\n    function owner()\\n        public\\n        view\\n        override(IUniversalVault, OwnableERC721)\\n        returns (address ownerAddress)\\n    {\\n        return OwnableERC721.owner();\\n    }\\n\\n    function getLockSetCount() external view override returns (uint256 count) {\\n        return _lockSet.length();\\n    }\\n\\n    function getLockAt(uint256 index) external view override returns (LockData memory lockData) {\\n        return _locks[_lockSet.at(index)];\\n    }\\n\\n    function getBalanceDelegated(address token, address delegate)\\n        external\\n        view\\n        override\\n        returns (uint256 balance)\\n    {\\n        return _locks[calculateLockID(delegate, token)].balance;\\n    }\\n\\n    function getBalanceLocked(address token) public view override returns (uint256 balance) {\\n        uint256 count = _lockSet.length();\\n        for (uint256 index; index < count; index++) {\\n            LockData storage _lockData = _locks[_lockSet.at(index)];\\n            if (_lockData.token == token && _lockData.balance > balance)\\n                balance = _lockData.balance;\\n        }\\n        return balance;\\n    }\\n\\n    function checkBalances() external view override returns (bool validity) {\\n        // iterate over all token locks and validate sufficient balance\\n        uint256 count = _lockSet.length();\\n        for (uint256 index; index < count; index++) {\\n            // fetch storage lock reference\\n            LockData storage _lockData = _locks[_lockSet.at(index)];\\n            // if insufficient balance and no\\u220ft shutdown, return false\\n            if (IERC20(_lockData.token).balanceOf(address(this)) < _lockData.balance) return false;\\n        }\\n        // if sufficient balance or shutdown, return true\\n        return true;\\n    }\\n\\n    /* user functions */\\n\\n    /// @notice Lock ERC20 tokens in the vault\\n    /// access control: called by delegate with signed permission from owner\\n    /// state machine: anytime\\n    /// state scope:\\n    /// - insert or update _locks\\n    /// - increase _nonce\\n    /// token transfer: none\\n    /// @param token Address of token being locked\\n    /// @param amount Amount of tokens being locked\\n    /// @param permission Permission signature payload\\n    function lock(\\n        address token,\\n        uint256 amount,\\n        bytes calldata permission\\n    )\\n        external\\n        override\\n        onlyValidSignature(\\n            getPermissionHash(LOCK_TYPEHASH, msg.sender, token, amount, _nonce),\\n            permission\\n        )\\n    {\\n        // get lock id\\n        bytes32 lockID = calculateLockID(msg.sender, token);\\n\\n        // add lock to storage\\n        if (_lockSet.contains(lockID)) {\\n            // if lock already exists, increase amount\\n            _locks[lockID].balance = _locks[lockID].balance.add(amount);\\n        } else {\\n            // if does not exist, create new lock\\n            // add lock to set\\n            assert(_lockSet.add(lockID));\\n            // add lock data to storage\\n            _locks[lockID] = LockData(msg.sender, token, amount);\\n        }\\n\\n        // validate sufficient balance\\n        require(\\n            IERC20(token).balanceOf(address(this)) >= _locks[lockID].balance,\\n            \\\"UniversalVault: insufficient balance\\\"\\n        );\\n\\n        // increase nonce\\n        _nonce += 1;\\n\\n        // emit event\\n        emit Locked(msg.sender, token, amount);\\n    }\\n\\n    /// @notice Unlock ERC20 tokens in the vault\\n    /// access control: called by delegate with signed permission from owner\\n    /// state machine: after valid lock from delegate\\n    /// state scope:\\n    /// - remove or update _locks\\n    /// - increase _nonce\\n    /// token transfer: none\\n    /// @param token Address of token being unlocked\\n    /// @param amount Amount of tokens being unlocked\\n    /// @param permission Permission signature payload\\n    function unlock(\\n        address token,\\n        uint256 amount,\\n        bytes calldata permission\\n    )\\n        external\\n        override\\n        onlyValidSignature(\\n            getPermissionHash(UNLOCK_TYPEHASH, msg.sender, token, amount, _nonce),\\n            permission\\n        )\\n    {\\n        // get lock id\\n        bytes32 lockID = calculateLockID(msg.sender, token);\\n\\n        // validate existing lock\\n        require(_lockSet.contains(lockID), \\\"UniversalVault: missing lock\\\");\\n\\n        // update lock data\\n        if (_locks[lockID].balance > amount) {\\n            // substract amount from lock balance\\n            _locks[lockID].balance = _locks[lockID].balance.sub(amount);\\n        } else {\\n            // delete lock data\\n            delete _locks[lockID];\\n            assert(_lockSet.remove(lockID));\\n        }\\n\\n        // increase nonce\\n        _nonce += 1;\\n\\n        // emit event\\n        emit Unlocked(msg.sender, token, amount);\\n    }\\n\\n    /// @notice Forcibly cancel delegate lock\\n    /// @dev This function will attempt to notify the delegate of the rage quit using\\n    ///      a fixed amount of gas.\\n    /// access control: only owner\\n    /// state machine: after valid lock from delegate\\n    /// state scope:\\n    /// - remove item from _locks\\n    /// token transfer: none\\n    /// @param delegate Address of delegate\\n    /// @param token Address of token being unlocked\\n    function rageQuit(address delegate, address token)\\n        external\\n        override\\n        onlyOwner\\n        returns (bool notified, string memory error)\\n    {\\n        // get lock id\\n        bytes32 lockID = calculateLockID(delegate, token);\\n\\n        // validate existing lock\\n        require(_lockSet.contains(lockID), \\\"UniversalVault: missing lock\\\");\\n\\n        // attempt to notify delegate\\n        if (delegate.isContract()) {\\n            // check for sufficient gas\\n            require(gasleft() >= RAGEQUIT_GAS, \\\"UniversalVault: insufficient gas\\\");\\n\\n            // attempt rageQuit notification\\n            try IRageQuit(delegate).rageQuit{gas: RAGEQUIT_GAS}() {\\n                notified = true;\\n            } catch Error(string memory res) {\\n                notified = false;\\n                error = res;\\n            } catch (bytes memory) {\\n                notified = false;\\n            }\\n        }\\n\\n        // update lock storage\\n        assert(_lockSet.remove(lockID));\\n        delete _locks[lockID];\\n\\n        // emit event\\n        emit RageQuit(delegate, token, notified, error);\\n    }\\n\\n    /// @notice Transfer ERC20 tokens out of vault\\n    /// access control: only owner\\n    /// state machine: when balance >= max(lock) + amount\\n    /// state scope: none\\n    /// token transfer: transfer any token\\n    /// @param token Address of token being transferred\\n    /// @param to Address of the recipient\\n    /// @param amount Amount of tokens to transfer\\n    function transferERC20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) external override onlyOwner {\\n        // check for sufficient balance\\n        require(\\n            IERC20(token).balanceOf(address(this)) >= getBalanceLocked(token).add(amount),\\n            \\\"UniversalVault: insufficient balance\\\"\\n        );\\n        // perform transfer\\n        TransferHelper.safeTransfer(token, to, amount);\\n    }\\n\\n    /// @notice Transfer ERC20 tokens out of vault\\n    /// access control: only owner\\n    /// state machine: when balance >= amount\\n    /// state scope: none\\n    /// token transfer: transfer any token\\n    /// @param to Address of the recipient\\n    /// @param amount Amount of ETH to transfer\\n    function transferETH(address to, uint256 amount) external payable override onlyOwner {\\n        // perform transfer\\n        TransferHelper.safeTransferETH(to, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xe4d9b6f62f99af9b0136df4b15e1aba885f7c7c16855420e22625d6d40e71618\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/crucible/EIP712.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/* solhint-disable max-line-length */\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private constant _TYPE_HASH =\\n        keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n\\n    constructor(string memory name, string memory version) {\\n        _HASHED_NAME = keccak256(bytes(name));\\n        _HASHED_VERSION = keccak256(bytes(version));\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 name,\\n        bytes32 version\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, name, version, _getChainId(), address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparatorV4(), structHash));\\n    }\\n\\n    function _getChainId() private view returns (uint256 chainId) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            chainId := chainid()\\n        }\\n    }\\n\\n    /**\\n     * @dev The hash of the name parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712NameHash() internal view virtual returns (bytes32) {\\n        return _HASHED_NAME;\\n    }\\n\\n    /**\\n     * @dev The hash of the version parameter for the EIP712 domain.\\n     *\\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\\n     * are a concern.\\n     */\\n    function _EIP712VersionHash() internal view virtual returns (bytes32) {\\n        return _HASHED_VERSION;\\n    }\\n}\\n\",\"keccak256\":\"0xe7af2d7afadad2e157a51ee02c50bda1744aded9d3937824e0d8f4a53e6f1b26\",\"license\":\"MIT\"},\"alchemist/contracts/crucible/ERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {ECDSA} from \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport {Address} from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\ninterface IERC1271 {\\n    function isValidSignature(bytes32 _messageHash, bytes memory _signature)\\n        external\\n        view\\n        returns (bytes4 magicValue);\\n}\\n\\nlibrary SignatureChecker {\\n    function isValidSignature(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        if (Address.isContract(signer)) {\\n            bytes4 selector = IERC1271.isValidSignature.selector;\\n            (bool success, bytes memory returndata) =\\n                signer.staticcall(abi.encodeWithSelector(selector, hash, signature));\\n            return success && abi.decode(returndata, (bytes4)) == selector;\\n        } else {\\n            return ECDSA.recover(hash, signature) == signer;\\n        }\\n    }\\n}\\n\\n/// @title ERC1271\\n/// @notice Module for ERC1271 compatibility\\nabstract contract ERC1271 is IERC1271 {\\n    // Valid magic value bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 internal constant VALID_SIG = IERC1271.isValidSignature.selector;\\n    // Invalid magic value\\n    bytes4 internal constant INVALID_SIG = bytes4(0);\\n\\n    modifier onlyValidSignature(bytes32 permissionHash, bytes memory signature) {\\n        require(\\n            isValidSignature(permissionHash, signature) == VALID_SIG,\\n            \\\"ERC1271: Invalid signature\\\"\\n        );\\n        _;\\n    }\\n\\n    function _getOwner() internal view virtual returns (address owner);\\n\\n    function isValidSignature(bytes32 permissionHash, bytes memory signature)\\n        public\\n        view\\n        override\\n        returns (bytes4)\\n    {\\n        return\\n            SignatureChecker.isValidSignature(_getOwner(), permissionHash, signature)\\n                ? VALID_SIG\\n                : INVALID_SIG;\\n    }\\n}\\n\",\"keccak256\":\"0x998477bfca3cf4fd801a6cb508bce132f3a3b699087af12cad99d82d52a9bb84\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/crucible/OwnableERC721.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/// @title OwnableERC721\\n/// @notice Use ERC721 ownership for access control\\ncontract OwnableERC721 {\\n    address private _nftAddress;\\n\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"OwnableERC721: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function _setNFT(address nftAddress) internal {\\n        _nftAddress = nftAddress;\\n    }\\n\\n    function nft() public view virtual returns (address nftAddress) {\\n        return _nftAddress;\\n    }\\n\\n    function owner() public view virtual returns (address ownerAddress) {\\n        return IERC721(_nftAddress).ownerOf(uint256(uint160(address(this))));\\n    }\\n}\\n\",\"keccak256\":\"0xfa2ceffc5eeca850fa7e1f46f10f416838553f8e7d66e0e09c3da67642bbaac7\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/factory/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\ninterface IFactory {\\n    function create(bytes calldata args) external returns (address instance);\\n\\n    function create2(bytes calldata args, bytes32 salt) external returns (address instance);\\n}\\n\",\"keccak256\":\"0x9aae95b220be96434e10884dabd1a4167942800b6b828bf75541eca818f6560c\",\"license\":\"GPL-3.0-only\"},\"alchemist/contracts/factory/InstanceRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ninterface IInstanceRegistry {\\n    /* events */\\n\\n    event InstanceAdded(address instance);\\n    event InstanceRemoved(address instance);\\n\\n    /* view functions */\\n\\n    function isInstance(address instance) external view returns (bool validity);\\n\\n    function instanceCount() external view returns (uint256 count);\\n\\n    function instanceAt(uint256 index) external view returns (address instance);\\n}\\n\\n/// @title InstanceRegistry\\ncontract InstanceRegistry is IInstanceRegistry {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /* storage */\\n\\n    EnumerableSet.AddressSet private _instanceSet;\\n\\n    /* view functions */\\n\\n    function isInstance(address instance) public view override returns (bool validity) {\\n        return _instanceSet.contains(instance);\\n    }\\n\\n    function instanceCount() public view override returns (uint256 count) {\\n        return _instanceSet.length();\\n    }\\n\\n    function instanceAt(uint256 index) public view override returns (address instance) {\\n        return _instanceSet.at(index);\\n    }\\n\\n    /* admin functions */\\n\\n    function _register(address instance) internal {\\n        require(_instanceSet.add(instance), \\\"InstanceRegistry: already registered\\\");\\n        emit InstanceAdded(instance);\\n    }\\n}\\n\",\"keccak256\":\"0xc74100043198fc3a6db43919a8b11a6bdf9a33f3f22c5577ed565c268898205d\",\"license\":\"GPL-3.0-only\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x60b0215121bf25612a6739fb2f1ec35f31ee82e4a8216c032c8243d904ab3aa9\",\"license\":\"MIT\"},\"src/contracts/aludel/AludelV3.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\npragma abicoder v2;\\n\\nimport {Initializable} from \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {EnumerableSet} from \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {TransferHelper} from \\\"@uniswap/lib/contracts/libraries/TransferHelper.sol\\\";\\n\\nimport {IFactory} from \\\"alchemist/contracts/factory/IFactory.sol\\\";\\nimport {IInstanceRegistry} from \\\"alchemist/contracts/factory/InstanceRegistry.sol\\\";\\nimport {IUniversalVault} from \\\"alchemist/contracts/crucible/Crucible.sol\\\";\\nimport {IRewardPool} from \\\"alchemist/contracts/aludel/RewardPool.sol\\\";\\nimport {Powered} from \\\"../powerSwitch/Powered.sol\\\";\\n\\nimport {IAludel} from \\\"./IAludel.sol\\\";\\nimport {IAludelV3} from \\\"./IAludelV3.sol\\\";\\nimport {IAludelHooks} from \\\"./IAludelHooks.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title Aludel\\n/// @notice Reward distribution contract with time multiplier\\n/// Access Control\\n/// - Power controller:\\n///     Can power off / shutdown the Aludel\\n///     Can withdraw rewards from reward pool once shutdown\\n/// - Aludel admin:\\n///     Can add funds to the Aludel, register bonus tokens, and whitelist new vault factories\\n///     Is a subset of proxy owner permissions\\n/// - User:\\n///     Can deposit / withdraw / ragequit\\n/// Aludel State Machine\\n/// - Online:\\n///     Aludel is operating normally, all functions are enabled\\n/// - Offline:\\n///     Aludel is temporarely disabled for maintenance\\n///     User deposits and withdrawls are disabled, ragequit remains enabled\\n///     Users can withdraw their stake through rageQuit() but forego their pending reward\\n///     Should only be used when downtime required for an upgrade\\n/// - Shutdown:\\n///     Aludel is permanently disabled\\n///     All functions are disabled with the exception of ragequit\\n///     Users can withdraw their stake through rageQuit()\\n///     Power controller can withdraw from the reward pool\\n///     Should only be used if Proxy Owner role is compromized\\ncontract AludelV3 is IAludelV3, Ownable, Initializable, Powered {\\n    using SafeMath for uint256;\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /* constants */\\n\\n    // An upper bound on the number of active stakes per vault is required to prevent\\n    // calls to rageQuit() from reverting.\\n    // With 30 stakes in a vault, ragequit costs 432811 gas which is conservatively lower\\n    // than the hardcoded limit of 500k gas on the vault.\\n    // This limit is configurable and could be increased in a future deployment.\\n    // Ultimately, to avoid a need for fixed upper bounds, the EVM would need to provide\\n    // an error code that allows for reliably catching out-of-gas errors on remote calls.\\n    uint256 public constant MAX_STAKES_PER_VAULT = 30;\\n    uint256 public constant MAX_REWARD_TOKENS = 50;\\n    uint256 public constant BASE_SHARES_PER_WEI = 1000000;\\n\\n    /* storage */\\n\\n    AludelData internal _aludel;\\n    mapping(address => VaultData) internal _vaults;\\n    EnumerableSet.AddressSet internal _bonusTokenSet;\\n    EnumerableSet.AddressSet internal _vaultFactorySet;\\n\\n\\n    address private _feeRecipient;\\n    uint16 private _feeBps;\\n\\n    struct AludelInitializationParams {\\n        address rewardPoolFactory;\\n        address powerSwitchFactory;\\n        address stakingToken;\\n        address rewardToken;\\n        IAludelHooks hookContract;\\n        RewardScaling rewardScaling;\\n    }\\n\\n    error FloorAboveCeiling();\\n    error ScalingTimeIsZero();\\n    error InvalidDuration();\\n    error VaultFactoryNotRegistered();\\n    error VaultAlreadyRegistered();\\n    error MaxBonusTokensReached();\\n    error InvalidAddress(address addr);\\n    error InvalidVault();\\n    error MaxStakesReached();\\n    error NoAmountStaked();\\n    error NoAmountUnstaked();\\n    error NoStakes();\\n    error InvalidAmountArray();\\n\\n    /* initializer */\\n\\n    function initializeLock() external override initializer {}\\n\\n    /// @notice Initizalize Aludel\\n    /// access control: only proxy constructor\\n    /// state machine: can only be called once\\n    /// state scope: set initialization variables\\n    /// token transfer: none\\n    function initialize(\\n        uint64 startTime,\\n        address ownerAddress,\\n        address feeRecipient,\\n        uint16 feeBps,\\n        bytes calldata data\\n    )\\n        external\\n        override\\n        initializer\\n    {\\n      \\n        (AludelInitializationParams memory params) = abi.decode(\\n            data, (AludelInitializationParams)\\n        );\\n\\n        _feeRecipient = feeRecipient;\\n        _feeBps = feeBps;\\n\\n        // the scaling floor must be smaller than ceiling\\n        if (params.rewardScaling.floor > params.rewardScaling.ceiling) {\\n            revert FloorAboveCeiling();\\n        }\\n\\n        // setting rewardScalingTime to 0 would cause divide by zero error\\n        // to disable reward scaling, use rewardScalingFloor == rewardScalingCeiling\\n        if (params.rewardScaling.time == 0) {\\n            revert ScalingTimeIsZero();\\n        }\\n\\n        // deploy power switch\\n        address powerSwitch = IFactory(params.powerSwitchFactory).create(\\n            abi.encode(ownerAddress, startTime)\\n        );\\n\\n        // // deploy reward pool\\n        address rewardPool =\\n            IFactory(params.rewardPoolFactory).create(abi.encode(powerSwitch));\\n\\n        // // set internal configs\\n        _transferOwnership(msg.sender);\\n        Powered._setPowerSwitch(powerSwitch);\\n\\n        // commit to storage\\n        _aludel.stakingToken = params.stakingToken;\\n        _aludel.rewardToken = params.rewardToken;\\n        _aludel.rewardPool = rewardPool;\\n        _aludel.rewardScaling = params.rewardScaling;\\n        _aludel.hookContract = params.hookContract;\\n\\n        // emit event\\n        emit AludelCreated(rewardPool, powerSwitch);\\n    }\\n\\n    /* getter functions */\\n\\n    function getBonusTokenSetLength()\\n        external\\n        view\\n        override\\n        returns (uint256 length)\\n    {\\n        return _bonusTokenSet.length();\\n    }\\n\\n    function getBonusTokenAtIndex(uint256 index)\\n        external\\n        view\\n        override\\n        returns (address bonusToken)\\n    {\\n        return _bonusTokenSet.at(index);\\n    }\\n\\n    function getVaultFactorySetLength()\\n        external\\n        view\\n        override\\n        returns (uint256 length)\\n    {\\n        return _vaultFactorySet.length();\\n    }\\n\\n    function getVaultFactoryAtIndex(uint256 index)\\n        external\\n        view\\n        override\\n        returns (address factory)\\n    {\\n        return _vaultFactorySet.at(index);\\n    }\\n\\n    function isValidVault(address target)\\n        public\\n        view\\n        override\\n        returns (bool validity)\\n    {\\n        // validate target is created from whitelisted vault factory\\n        for (uint256 index = 0; index < _vaultFactorySet.length(); index++) {\\n            if (\\n                IInstanceRegistry(_vaultFactorySet.at(index)).isInstance(target)\\n            ) {\\n                return true;\\n            }\\n        }\\n        // explicit return\\n        return false;\\n    }\\n\\n    function isValidAddress(address target)\\n        public\\n        view\\n        override\\n        returns (bool validity)\\n    {\\n        // sanity check target for potential input errors\\n        return\\n            target != address(this) &&\\n            target != address(0) &&\\n            target != _aludel.stakingToken &&\\n            target != _aludel.rewardToken &&\\n            target != _aludel.rewardPool &&\\n            !_bonusTokenSet.contains(target);\\n    }\\n\\n    /* Aludel getters */\\n\\n    function getAludelData()\\n        external\\n        view\\n        override\\n        returns (AludelData memory aludel)\\n    {\\n        return _aludel;\\n    }\\n\\n    function getCurrentTotalStakeUnits()\\n        public\\n        view\\n        override\\n        returns (uint256 totalStakeUnits)\\n    {\\n        // calculate new stake units\\n        return getFutureTotalStakeUnits(block.timestamp);\\n    }\\n\\n    function getFutureTotalStakeUnits(uint256 timestamp)\\n        public\\n        view\\n        override\\n        returns (uint256 totalStakeUnits)\\n    {\\n        // return early if no change\\n        if (timestamp == _aludel.lastUpdate) return _aludel.totalStakeUnits;\\n        // calculate new stake units\\n        uint256 newStakeUnits =\\n            calculateStakeUnits(_aludel.totalStake, _aludel.lastUpdate, timestamp);\\n        // add to cached total\\n        totalStakeUnits = _aludel.totalStakeUnits.add(newStakeUnits);\\n        // explicit return\\n        return totalStakeUnits;\\n    }\\n\\n    /* vault getters */\\n\\n    function getVaultData(address vault)\\n        external\\n        view\\n        override\\n        returns (VaultData memory vaultData)\\n    {\\n        return _vaults[vault];\\n    }\\n\\n    /* pure functions */\\n\\n    function calculateTotalStakeUnits(\\n        StakeData[] memory stakes,\\n        uint256 timestamp\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 totalStakeUnits)\\n    {\\n        for (uint256 index; index < stakes.length; index++) {\\n            // reference stake\\n            StakeData memory stakeData = stakes[index];\\n            // calculate stake units\\n            uint256 stakeUnits =\\n            calculateStakeUnits(stakeData.amount, stakeData.timestamp, timestamp);\\n            // add to running total\\n            totalStakeUnits = totalStakeUnits.add(stakeUnits);\\n        }\\n    }\\n\\n    function calculateStakeUnits(uint256 amount, uint256 start, uint256 end)\\n        public\\n        pure\\n        override\\n        returns (uint256 stakeUnits)\\n    {\\n        // calculate duration\\n        uint256 duration = end.sub(start);\\n        // calculate stake units\\n        stakeUnits = duration.mul(amount);\\n        // explicit return\\n        return stakeUnits;\\n    }\\n\\n    function calculateUnlockedRewards(\\n        RewardSchedule[] memory rewardSchedules,\\n        uint256 rewardBalance,\\n        uint256 sharesOutstanding,\\n        uint256 timestamp\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 unlockedRewards)\\n    {\\n        // return 0 if no registered schedules\\n        if (rewardSchedules.length == 0) {\\n            return 0;\\n        }\\n\\n        // calculate reward shares locked across all reward schedules\\n        uint256 sharesLocked;\\n        for (uint256 index = 0; index < rewardSchedules.length; index++) {\\n            // fetch reward schedule storage reference\\n            RewardSchedule memory schedule = rewardSchedules[index];\\n\\n            // caculate amount of shares available on this schedule\\n            // if (now - start) < duration\\n            //   sharesLocked = shares - (shares * (now - start) / duration)\\n            // else\\n            //   sharesLocked = 0\\n            uint256 currentSharesLocked = 0;\\n            if (timestamp.sub(schedule.start) < schedule.duration) {\\n                currentSharesLocked = schedule.shares.sub(\\n                    schedule.shares.mul(timestamp.sub(schedule.start)).div(schedule.duration)\\n                );\\n            }\\n\\n            // add to running total\\n            sharesLocked = sharesLocked.add(currentSharesLocked);\\n        }\\n\\n        // convert shares to reward\\n        // rewardLocked = sharesLocked * rewardBalance / sharesOutstanding\\n        uint256 rewardLocked =\\n            sharesLocked.mul(rewardBalance).div(sharesOutstanding);\\n\\n        // calculate amount available\\n        // unlockedRewards = rewardBalance - rewardLocked\\n        unlockedRewards = rewardBalance.sub(rewardLocked);\\n\\n        // explicit return\\n        return unlockedRewards;\\n    }\\n\\n    function calculateReward(\\n        uint256 unlockedRewards,\\n        uint256 stakeAmount,\\n        uint256 stakeDuration,\\n        uint256 totalStakeUnits,\\n        RewardScaling memory rewardScaling\\n    )\\n        public\\n        pure\\n        override\\n        returns (uint256 reward)\\n    {\\n        // calculate time weighted stake\\n        uint256 stakeUnits = stakeAmount.mul(stakeDuration);\\n\\n        // calculate base reward\\n        // baseReward = unlockedRewards * stakeUnits / totalStakeUnits\\n        uint256 baseReward = 0;\\n        if (totalStakeUnits != 0) {\\n            // scale reward according to proportional weight\\n            baseReward = unlockedRewards.mul(stakeUnits).div(totalStakeUnits);\\n        }\\n\\n        // calculate scaled reward\\n        // if no scaling or scaling period completed\\n        //   reward = baseReward\\n        // else\\n        //   minReward = baseReward * scalingFloor / scalingCeiling\\n        //   bonusReward = baseReward\\n        //                 * (scalingCeiling - scalingFloor) / scalingCeiling\\n        //                 * duration / scalingTime\\n        //   reward = minReward + bonusReward\\n        if (\\n            stakeDuration\\n                >= rewardScaling.time\\n                || rewardScaling.floor\\n                == rewardScaling.ceiling\\n        ) {\\n            // no reward scaling applied\\n            reward = baseReward;\\n        } else {\\n            // calculate minimum reward using scaling floor\\n            uint256 minReward =\\n                baseReward.mul(rewardScaling.floor).div(rewardScaling.ceiling);\\n\\n            // calculate bonus reward with vested portion of scaling factor\\n            uint256 bonusReward = baseReward\\n                    .mul(stakeDuration)\\n                    .mul(rewardScaling.ceiling.sub(rewardScaling.floor))\\n                    .div(rewardScaling.ceiling)\\n                    .div(rewardScaling.time);\\n\\n            // add minimum reward and bonus reward\\n            reward = minReward.add(bonusReward);\\n        }\\n\\n        // explicit return\\n        return reward;\\n    }\\n\\n    /* admin functions */\\n\\n    /// @notice Add funds to the Aludel\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    /// state scope:\\n    ///   - increase _aludel.rewardSharesOutstanding\\n    ///   - append to _aludel.rewardSchedules\\n    /// token transfer: transfer staking tokens from msg.sender to reward pool\\n    /// @param amount uint256 Amount of reward tokens to deposit\\n    /// @param duration uint256 Duration over which to linearly unlock rewards\\n    function fund(uint256 amount, uint256 duration)\\n        external\\n        override\\n        onlyOwner\\n        onlyOnline\\n    {\\n        // validate duration\\n        if (duration == 0) {\\n            revert InvalidDuration();\\n        }\\n\\n        uint256 fee = amount.mul(_feeBps).div(10000);\\n        amount = amount.sub(fee);\\n\\n        // transfer reward tokens to `_feeRecipient` \\n        TransferHelper.safeTransferFrom(\\n            _aludel.rewardToken,\\n            msg.sender,\\n            _feeRecipient,\\n            fee\\n        );\\n        \\n        // create new reward shares\\n        // if existing rewards on this Aludel\\n        //   mint new shares proportional to % change in rewards remaining\\n        //   newShares = remainingShares * newReward / remainingRewards\\n        // else\\n        //   mint new shares with BASE_SHARES_PER_WEI initial conversion rate\\n        //   store as fixed point number with same  of decimals as reward token\\n        uint256 newRewardShares;\\n        if (_aludel.rewardSharesOutstanding > 0) {\\n            uint256 remainingRewards =\\n                IERC20(_aludel.rewardToken).balanceOf(_aludel.rewardPool);\\n            newRewardShares =\\n                _aludel.rewardSharesOutstanding.mul(amount).div(remainingRewards);\\n        } else {\\n            newRewardShares = amount.mul(BASE_SHARES_PER_WEI);\\n        }\\n\\n        // add reward shares to total\\n        _aludel.rewardSharesOutstanding =\\n            _aludel.rewardSharesOutstanding.add(newRewardShares);\\n\\n        // store new reward schedule\\n        _aludel.rewardSchedules.push(RewardSchedule(duration, block.timestamp, newRewardShares));\\n\\n        // transfer reward tokens to reward pool\\n        TransferHelper.safeTransferFrom(\\n            _aludel.rewardToken,\\n            msg.sender,\\n            _aludel.rewardPool,\\n            amount\\n        );\\n\\n        // emit event\\n        emit AludelFunded(amount, duration);\\n    }\\n\\n    /// @notice Add vault factory to whitelist\\n    /// @dev use this function to enable stakes to vaults coming from the specified\\n    ///      factory contract\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - not shutdown\\n    /// state scope:\\n    ///   - append to _vaultFactorySet\\n    /// token transfer: none\\n    /// @param factory address The address of the vault factory\\n    function registerVaultFactory(address factory)\\n        external\\n        virtual\\n        override\\n        onlyOwner\\n        notShutdown\\n    {\\n        // add factory to set\\n        if (!_vaultFactorySet.add(factory)) {\\n            revert VaultAlreadyRegistered();\\n        }\\n        // emit event\\n        emit VaultFactoryRegistered(factory);\\n    }\\n\\n    /// @notice Remove vault factory from whitelist\\n    /// @dev use this function to disable new stakes to vaults coming from the specified\\n    ///      factory contract.\\n    ///      note: vaults with existing stakes from this factory are sill able to unstake\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - not shutdown\\n    /// state scope:\\n    ///   - remove from _vaultFactorySet\\n    /// token transfer: none\\n    /// @param factory address The address of the vault factory\\n    function removeVaultFactory(address factory)\\n        external\\n        virtual\\n        override\\n        onlyOwner\\n        notShutdown\\n    {\\n        // remove factory from set\\n        if (!_vaultFactorySet.remove(factory)) {\\n            revert VaultFactoryNotRegistered();\\n        }\\n        // emit event\\n        emit VaultFactoryRemoved(factory);\\n    }\\n\\n    /// @notice Register bonus token for distribution\\n    /// @dev use this function to enable distribution of any ERC20 held by the RewardPool contract\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    /// state scope:\\n    ///   - append to _bonusTokenSet\\n    /// token transfer: none\\n    /// @param bonusToken address The address of the bonus token\\n    function registerBonusToken(address bonusToken)\\n        external\\n        virtual\\n        override\\n        onlyOwner\\n        onlyOnline\\n    {\\n        // verify valid bonus token\\n        _validateAddress(bonusToken);\\n\\n        // verify bonus token count\\n        if (_bonusTokenSet.length() >= MAX_REWARD_TOKENS) {\\n            revert MaxBonusTokensReached();\\n        }\\n        // add token to set\\n        assert(_bonusTokenSet.add(bonusToken));\\n\\n        // emit event\\n        emit BonusTokenRegistered(bonusToken);\\n    }\\n\\n    /// @notice Rescue tokens from RewardPool\\n    /// @dev use this function to rescue tokens from RewardPool contract\\n    ///      without distributing to stakers or triggering emergency shutdown\\n    /// access control: only admin\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    /// state scope: none\\n    /// token transfer: transfer requested token from RewardPool to recipient\\n    /// @param token address The address of the token to rescue\\n    /// @param recipient address The address of the recipient\\n    /// @param amount uint256 The amount of tokens to rescue\\n    function rescueTokensFromRewardPool(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    )\\n        external\\n        override\\n        onlyOwner\\n        onlyOnline\\n    {\\n        // verify recipient\\n        _validateAddress(recipient);\\n\\n        // check not attempting to unstake reward token\\n        if (token == _aludel.rewardToken) {\\n            revert InvalidAddress(token);\\n        }\\n        // check not attempting to wthdraw bonus token\\n        if (_bonusTokenSet.contains(token)) {\\n            revert InvalidAddress(token);\\n        }\\n\\n        // transfer tokens to recipient\\n        IRewardPool(_aludel.rewardPool).sendERC20(token, recipient, amount);\\n    }\\n\\n    /* user functions */\\n\\n    /// @notice Stake tokens\\n    /// access control: anyone with a valid permission\\n    /// state machine:\\n    ///   - can be called multiple times\\n    ///   - only online\\n    ///   - when vault exists on this Aludel\\n    /// state scope:\\n    ///   - append to _vaults[vault].stakes\\n    ///   - increase _vaults[vault].totalStake\\n    ///   - increase _aludel.totalStake\\n    ///   - increase _aludel.totalStakeUnits\\n    ///   - increase _aludel.lastUpdate\\n    /// token transfer: transfer staking tokens from msg.sender to vault\\n    /// @param vault address The address of the vault to stake from\\n    /// @param amount uint256 The amount of staking tokens to stake\\n    /// @param permission bytes The signed lock permission for the universal vault\\n\\n    function stake(address vault, uint256 amount, bytes calldata permission)\\n        external\\n        override\\n        onlyOnline\\n        hasStarted\\n    {\\n        // verify vault is valid\\n        if (!isValidVault(vault)) {\\n            revert InvalidVault();\\n        }\\n        // verify non-zero amount\\n        if (amount == 0) {\\n            revert NoAmountStaked();\\n        }\\n\\n        // fetch vault storage reference\\n        VaultData storage vaultData = _vaults[vault];\\n\\n        // verify stakes boundary not reached\\n        if (vaultData.stakes.length >= MAX_STAKES_PER_VAULT) {\\n            revert MaxStakesReached();\\n        }\\n\\n        // update cached sum of stake units across all vaults\\n        _updateTotalStakeUnits();\\n\\n        // store amount and timestamp\\n        vaultData.stakes.push(StakeData(amount, block.timestamp));\\n\\n        // update cached total vault and Aludel amounts\\n        vaultData.totalStake = vaultData.totalStake.add(amount);\\n        _aludel.totalStake = _aludel.totalStake.add(amount);\\n\\n        // call lock on vault\\n        IUniversalVault(vault).lock(_aludel.stakingToken, amount, permission);\\n\\n        // emit event\\n        emit Staked(vault, amount);\\n    }\\n\\n    /// @notice Unstake staking tokens and claim reward\\n    /// @dev rewards can only be claimed when unstaking, thus reseting the reward multiplier\\n    /// access control: anyone with a valid permission\\n    /// state machine:\\n    ///   - when vault exists on this Aludel\\n    ///   - after stake from vault\\n    ///   - can be called multiple times while sufficient stake remains\\n    ///   - only online\\n    /// state scope:\\n    ///   - decrease _aludel.rewardSharesOutstanding\\n    ///   - decrease _aludel.totalStake\\n    ///   - increase _aludel.lastUpdate\\n    ///   - modify _aludel.totalStakeUnits\\n    ///   - modify _vaults[vault].stakes\\n    ///   - decrease _vaults[vault].totalStake\\n    /// token transfer:\\n    ///   - transfer reward tokens from reward pool to vault\\n    ///   - transfer bonus tokens from reward pool to vault\\n    /// @param vault address The vault to unstake from\\n    /// @param indices uint256 The amount of staking tokens to unstake\\n    /// @param amounts uint256 The amount of staking tokens to unstake\\n    /// @param permission bytes The signed lock permission for the universal vault\\n    function unstakeAndClaim(\\n        address vault,\\n        uint256[] calldata indices,\\n        uint256[] calldata amounts,\\n        bytes calldata permission\\n    )\\n        external\\n        override\\n        onlyOnline\\n        hasStarted\\n    {\\n        // fetch vault storage reference\\n        VaultData storage vaultData = _vaults[vault];\\n\\n        // update cached sum of stake units across all vaults\\n        _updateTotalStakeUnits();\\n\\n        // get reward amount remaining\\n        uint256 remainingRewards =\\n            IERC20(_aludel.rewardToken).balanceOf(_aludel.rewardPool);\\n\\n        // calculate vested portion of reward pool\\n        uint256 unlockedRewards = calculateUnlockedRewards(\\n                _aludel.rewardSchedules,\\n                remainingRewards,\\n                _aludel.rewardSharesOutstanding,\\n                block.timestamp\\n            );\\n\\n        (uint256 reward, uint256 amount) = _unstake(\\n            vaultData.stakes,\\n            unlockedRewards,\\n            indices,\\n            amounts            \\n        );\\n\\n        // verify non-zero amount\\n        if (amount == 0) {\\n            revert NoAmountUnstaked();\\n        }\\n\\n        // update cached stake totals\\n        vaultData.totalStake = vaultData.totalStake.sub(amount);\\n        _aludel.totalStake = _aludel.totalStake.sub(amount);\\n\\n        // unlock staking tokens from vault\\n        IUniversalVault(vault).unlock(_aludel.stakingToken, amount, permission);\\n\\n        // emit event\\n        emit Unstaked(vault, amount);\\n        // only perform on non-zero reward\\n        _claim(vault, reward, remainingRewards);\\n\\n    }\\n\\n    function _unstake(\\n        StakeData[] storage stakes,\\n        uint256 unlockedRewards,\\n        uint256[] memory indices,\\n        uint256[] memory amounts\\n    ) internal returns(uint256 reward, uint256 unstakedAmount) {\\n\\n        uint256 poppedStakes = 0;\\n\\n        for (uint256 metaIndex = 0; metaIndex< indices.length; metaIndex++) {\\n            uint256 computedStakeIndex = indices[metaIndex] - poppedStakes;\\n            StakeData memory currentStake = stakes[computedStakeIndex];\\n            unstakedAmount += amounts[metaIndex];\\n            if (currentStake.amount < amounts[metaIndex]) {\\n                revert InvalidAmountArray();\\n            } \\n            if(currentStake.amount == amounts[metaIndex]){\\n                stakes[computedStakeIndex] = stakes[stakes.length-1];\\n                poppedStakes+=1;\\n                stakes.pop();\\n            } else {\\n                stakes[computedStakeIndex].amount -= amounts[metaIndex];\\n                currentStake.amount -= amounts[metaIndex];\\n            }\\n            if (address(_aludel.hookContract) != address(0)) {\\n                _aludel.hookContract.unstakeAndClaimPost(currentStake);\\n            }\\n            uint256 stakeDuration = block.timestamp - currentStake.timestamp;\\n        \\n            uint256 currentReward = calculateReward(\\n                unlockedRewards,\\n                currentStake.amount,\\n                stakeDuration,\\n                _aludel.totalStakeUnits,\\n                _aludel.rewardScaling\\n            );\\n            reward += currentReward;\\n            unlockedRewards -= currentReward;\\n\\n            _aludel.totalStakeUnits -= amounts[metaIndex].mul(stakeDuration);\\n        }\\n    }\\n\\n    function _claim(address vault, uint256 reward, uint256 remainingRewards) public {\\n        if (reward > 0) {\\n\\n            // calculate shares to burn\\n            // sharesToBurn = sharesOutstanding * reward / remainingRewards\\n            uint256 sharesToBurn =\\n            _aludel.rewardSharesOutstanding.mul(reward).div(remainingRewards);\\n\\n            // burn claimed shares\\n            _aludel.rewardSharesOutstanding =\\n                _aludel.rewardSharesOutstanding.sub(sharesToBurn);\\n\\n            // transfer bonus tokens from reward pool to vault\\n            if (_bonusTokenSet.length() > 0) {\\n                for (\\n                    uint256 index = 0; index < _bonusTokenSet.length(); index++\\n                ) {\\n                    // fetch bonus token address reference\\n                    address bonusToken = _bonusTokenSet.at(index);\\n\\n                    // calculate bonus token amount\\n                    // bonusAmount = bonusRemaining * reward / remainingRewards\\n                    uint256 bonusAmount =\\n                    IERC20(bonusToken).balanceOf(_aludel.rewardPool).mul(reward).div(\\n                            remainingRewards\\n                        );\\n\\n                    // transfer bonus token\\n                    IRewardPool(_aludel.rewardPool).sendERC20(bonusToken, vault, bonusAmount);\\n\\n                    // emit event\\n                    emit RewardClaimed(vault, bonusToken, bonusAmount);\\n                }\\n            }\\n\\n            // transfer reward tokens from reward pool to vault\\n            IRewardPool(_aludel.rewardPool).sendERC20(_aludel.rewardToken, vault, reward);\\n\\n            // emit event\\n            emit RewardClaimed(vault, _aludel.rewardToken, reward);\\n        }\\n    }\\n\\n    /// @notice Exit Aludel without claiming reward\\n    /// @dev This function should never revert when correctly called by the vault.\\n    ///      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to\\n    ///      place an upper bound on the for loop in calculateTotalStakeUnits().\\n    /// access control: only callable by the vault directly\\n    /// state machine:\\n    ///   - when vault exists on this Aludel\\n    ///   - when active stake from this vault\\n    ///   - any power state\\n    /// state scope:\\n    ///   - decrease _aludel.totalStake\\n    ///   - increase _aludel.lastUpdate\\n    ///   - modify _aludel.totalStakeUnits\\n    ///   - delete _vaults[vault]\\n    /// token transfer: none\\n    function rageQuit() external virtual override {\\n        // fetch vault storage reference\\n        VaultData storage _vaultData = _vaults[msg.sender];\\n\\n        // revert if no active stakes\\n        if (_vaultData.stakes.length == 0) {\\n            revert NoStakes();\\n        }\\n\\n        // update cached sum of stake units across all vaults\\n        _updateTotalStakeUnits();\\n\\n        // emit event\\n        emit Unstaked(msg.sender, _vaultData.totalStake);\\n\\n        // update cached totals\\n        _aludel.totalStake = _aludel.totalStake.sub(_vaultData.totalStake);\\n        _aludel.totalStakeUnits = _aludel.totalStakeUnits.sub(\\n            calculateTotalStakeUnits(_vaultData.stakes, block.timestamp)\\n        );\\n\\n        // delete stake data\\n        delete _vaults[msg.sender];\\n    }\\n\\n    /* convenience functions */\\n\\n    function _updateTotalStakeUnits() internal virtual {\\n        // update cached totalStakeUnits\\n        _aludel.totalStakeUnits = getCurrentTotalStakeUnits();\\n        // update cached lastUpdate\\n        _aludel.lastUpdate = block.timestamp;\\n    }\\n\\n    function _validateAddress(address target) internal view virtual {\\n        // sanity check target for potential input errors\\n        if (!isValidAddress(target)) {\\n            revert InvalidAddress(target);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x05e60451ff9b7f4f5ff57118e640e4e2081559cdb12d7cfd6ed5d1e9a3bbac93\",\"license\":\"GPL-3.0\"},\"src/contracts/aludel/IAludel.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\npragma abicoder v2;\\n\\ninterface IRageQuit {\\n    function rageQuit() external;\\n}\\n\\ninterface IAludel is IRageQuit {\\n    /* admin events */\\n\\n    event AludelCreated(address rewardPool, address powerSwitch);\\n    event AludelFunded(uint256 amount, uint256 duration);\\n    event BonusTokenRegistered(address token);\\n    event VaultFactoryRegistered(address factory);\\n    event VaultFactoryRemoved(address factory);\\n\\n    /* user events */\\n\\n    event Staked(address vault, uint256 amount);\\n    event Unstaked(address vault, uint256 amount);\\n    event RewardClaimed(address vault, address token, uint256 amount);\\n\\n    /* data types */\\n\\n    struct AludelData {\\n        address stakingToken;\\n        address rewardToken;\\n        address rewardPool;\\n        RewardScaling rewardScaling;\\n        uint256 rewardSharesOutstanding;\\n        uint256 totalStake;\\n        uint256 totalStakeUnits;\\n        uint256 lastUpdate;\\n        RewardSchedule[] rewardSchedules;\\n    }\\n\\n    struct RewardSchedule {\\n        uint256 duration;\\n        uint256 start;\\n        uint256 shares;\\n    }\\n\\n    struct VaultData {\\n        uint256 totalStake;\\n        StakeData[] stakes;\\n    }\\n\\n    struct StakeData {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    struct RewardScaling {\\n        uint256 floor;\\n        uint256 ceiling;\\n        uint256 time;\\n    }\\n\\n    struct RewardOutput {\\n        uint256 lastStakeAmount;\\n        uint256 newStakesCount;\\n        uint256 reward;\\n        uint256 newTotalStakeUnits;\\n    }\\n\\n    function initializeLock() external;\\n\\n    function initialize(\\n        uint64 startTime,\\n        address ownerAddress,\\n        address feeRecipient,\\n        uint16 feeBps,\\n        bytes calldata\\n    ) external;\\n\\n    /* user functions */\\n\\n    function stake(address vault, uint256 amount, bytes calldata permission)\\n        external;\\n\\n    function unstakeAndClaim(\\n        address vault,\\n        uint256 amount,\\n        bytes calldata permission\\n    )\\n        external;\\n\\n    /* admin functions */\\n\\n    function fund(uint256 amount, uint256 duration) external;\\n\\n    function registerVaultFactory(address factory) external;\\n\\n    function removeVaultFactory(address factory) external;\\n\\n    function registerBonusToken(address bonusToken) external;\\n\\n    function rescueTokensFromRewardPool(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    )\\n        external;\\n\\n    /* getter functions */\\n\\n    function getAludelData()\\n        external\\n        view\\n        returns (AludelData memory aludel);\\n\\n    function getBonusTokenSetLength()\\n        external\\n        view\\n        returns (uint256 length);\\n\\n    function getBonusTokenAtIndex(uint256 index)\\n        external\\n        view\\n        returns (address bonusToken);\\n\\n    function getVaultFactorySetLength()\\n        external\\n        view\\n        returns (uint256 length);\\n\\n    function getVaultFactoryAtIndex(uint256 index)\\n        external\\n        view\\n        returns (address factory);\\n\\n    function getVaultData(address vault)\\n        external\\n        view\\n        returns (VaultData memory vaultData);\\n\\n    function isValidAddress(address target)\\n        external\\n        view\\n        returns (bool validity);\\n\\n    function isValidVault(address target)\\n        external\\n        view\\n        returns (bool validity);\\n\\n    function getCurrentTotalStakeUnits()\\n        external\\n        view\\n        returns (uint256 totalStakeUnits);\\n\\n    function getFutureTotalStakeUnits(uint256 timestamp)\\n        external\\n        view\\n        returns (uint256 totalStakeUnits);\\n\\n    /* pure functions */\\n\\n    function calculateTotalStakeUnits(\\n        StakeData[] memory stakes,\\n        uint256 timestamp\\n    )\\n        external\\n        pure\\n        returns (uint256 totalStakeUnits);\\n\\n    function calculateStakeUnits(uint256 amount, uint256 start, uint256 end)\\n        external\\n        pure\\n        returns (uint256 stakeUnits);\\n\\n    function calculateUnlockedRewards(\\n        RewardSchedule[] memory rewardSchedules,\\n        uint256 rewardBalance,\\n        uint256 sharesOutstanding,\\n        uint256 timestamp\\n    )\\n        external\\n        pure\\n        returns (uint256 unlockedRewards);\\n\\n    function calculateRewardFromStakes(\\n        StakeData[] memory stakes,\\n        uint256 unstakeAmount,\\n        uint256 unlockedRewards,\\n        uint256 totalStakeUnits,\\n        uint256 timestamp,\\n        RewardScaling memory rewardScaling\\n    )\\n        external\\n        pure\\n        returns (RewardOutput memory out);\\n\\n    function calculateReward(\\n        uint256 unlockedRewards,\\n        uint256 stakeAmount,\\n        uint256 stakeDuration,\\n        uint256 totalStakeUnits,\\n        RewardScaling memory rewardScaling\\n    )\\n        external\\n        pure\\n        returns (uint256 reward);\\n}\\n\",\"keccak256\":\"0x03feac9d295f4969f9bb3dd96e043fc7d442f7ba6569e49c3f314b990dce671e\",\"license\":\"GPL-3.0-only\"},\"src/contracts/aludel/IAludelHooks.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport {IAludelV3} from \\\"./IAludelV3.sol\\\";\\n\\ninterface IAludelHooks {\\n    function unstakeAndClaimPost(IAludelV3.StakeData memory stake) external;\\n}\\n\",\"keccak256\":\"0x609014969a7031ea4f492550bf3479ffcb96de45c2527d5216fe55cf4659d354\",\"license\":\"GPL-3.0\"},\"src/contracts/aludel/IAludelV3.sol\":{\"content\":\"\\n// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport {IAludelHooks} from \\\"./IAludelHooks.sol\\\";\\n\\npragma abicoder v2;\\n\\ninterface IRageQuit {\\n    function rageQuit() external;\\n}\\n\\ninterface IAludelV3 is IRageQuit {\\n    /* admin events */\\n\\n    event AludelCreated(address rewardPool, address powerSwitch);\\n    event AludelFunded(uint256 amount, uint256 duration);\\n    event BonusTokenRegistered(address token);\\n    event VaultFactoryRegistered(address factory);\\n    event VaultFactoryRemoved(address factory);\\n\\n    /* user events */\\n\\n    event Staked(address vault, uint256 amount);\\n    event Unstaked(address vault, uint256 amount);\\n    event RewardClaimed(address vault, address token, uint256 amount);\\n\\n    /* data types */\\n\\n    struct AludelData {\\n        address stakingToken;\\n        address rewardToken;\\n        address rewardPool;\\n        RewardScaling rewardScaling;\\n        uint256 rewardSharesOutstanding;\\n        uint256 totalStake;\\n        uint256 totalStakeUnits;\\n        uint256 lastUpdate;\\n        IAludelHooks hookContract;\\n        RewardSchedule[] rewardSchedules;\\n    }\\n\\n    struct RewardSchedule {\\n        uint256 duration;\\n        uint256 start;\\n        uint256 shares;\\n    }\\n\\n    struct VaultData {\\n        uint256 totalStake;\\n        StakeData[] stakes;\\n    }\\n\\n    struct StakeData {\\n        uint256 amount;\\n        uint256 timestamp;\\n    }\\n\\n    struct RewardScaling {\\n        uint256 floor;\\n        uint256 ceiling;\\n        uint256 time;\\n    }\\n\\n    struct RewardOutput {\\n        uint256 lastStakeAmount;\\n        uint256 newStakesCount;\\n        uint256 reward;\\n        uint256 newTotalStakeUnits;\\n    }\\n\\n    function initializeLock() external;\\n\\n    function initialize(\\n        uint64 startTime,\\n        address ownerAddress,\\n        address feeRecipient,\\n        uint16 feeBps,\\n        bytes calldata\\n    ) external;\\n\\n    /* user functions */\\n\\n    function stake(address vault, uint256 amount, bytes calldata permission)\\n        external;\\n\\n    function unstakeAndClaim(\\n        address vault,\\n        uint256[] calldata indices,\\n        uint256[] calldata amounts,\\n        bytes calldata permission\\n    )\\n        external;\\n\\n    /* admin functions */\\n\\n    function fund(uint256 amount, uint256 duration) external;\\n\\n    function registerVaultFactory(address factory) external;\\n\\n    function removeVaultFactory(address factory) external;\\n\\n    function registerBonusToken(address bonusToken) external;\\n\\n    function rescueTokensFromRewardPool(\\n        address token,\\n        address recipient,\\n        uint256 amount\\n    )\\n        external;\\n\\n    /* getter functions */\\n\\n    function getAludelData()\\n        external\\n        view\\n        returns (AludelData memory aludel);\\n\\n    function getBonusTokenSetLength()\\n        external\\n        view\\n        returns (uint256 length);\\n\\n    function getBonusTokenAtIndex(uint256 index)\\n        external\\n        view\\n        returns (address bonusToken);\\n\\n    function getVaultFactorySetLength()\\n        external\\n        view\\n        returns (uint256 length);\\n\\n    function getVaultFactoryAtIndex(uint256 index)\\n        external\\n        view\\n        returns (address factory);\\n\\n    function getVaultData(address vault)\\n        external\\n        view\\n        returns (VaultData memory vaultData);\\n\\n    function isValidAddress(address target)\\n        external\\n        view\\n        returns (bool validity);\\n\\n    function isValidVault(address target)\\n        external\\n        view\\n        returns (bool validity);\\n\\n    function getCurrentTotalStakeUnits()\\n        external\\n        view\\n        returns (uint256 totalStakeUnits);\\n\\n    function getFutureTotalStakeUnits(uint256 timestamp)\\n        external\\n        view\\n        returns (uint256 totalStakeUnits);\\n\\n    /* pure functions */\\n\\n    function calculateTotalStakeUnits(\\n        StakeData[] memory stakes,\\n        uint256 timestamp\\n    )\\n        external\\n        pure\\n        returns (uint256 totalStakeUnits);\\n\\n    function calculateStakeUnits(uint256 amount, uint256 start, uint256 end)\\n        external\\n        pure\\n        returns (uint256 stakeUnits);\\n\\n    function calculateUnlockedRewards(\\n        RewardSchedule[] memory rewardSchedules,\\n        uint256 rewardBalance,\\n        uint256 sharesOutstanding,\\n        uint256 timestamp\\n    )\\n        external\\n        pure\\n        returns (uint256 unlockedRewards);\\n\\n    function calculateReward(\\n        uint256 unlockedRewards,\\n        uint256 stakeAmount,\\n        uint256 stakeDuration,\\n        uint256 totalStakeUnits,\\n        RewardScaling memory rewardScaling\\n    )\\n        external\\n        pure\\n        returns (uint256 reward);\\n}\\n\",\"keccak256\":\"0x2e39c4ecd8e3bc031651c606af71d58396a67f1ef355b7d086411ba8f60428e0\",\"license\":\"GPL-3.0-only\"},\"src/contracts/powerSwitch/PowerSwitch.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IPowerSwitch {\\n    /* admin events */\\n\\n    event PowerOn();\\n    event PowerOff();\\n    event EmergencyShutdown();\\n\\n    /* data types */\\n\\n    enum State {\\n        Online,\\n        Offline,\\n        Shutdown,\\n        NotStarted\\n    }\\n\\n    /* admin functions */\\n\\n    function powerOn() external;\\n\\n    function powerOff() external;\\n\\n    function emergencyShutdown() external;\\n\\n    /* view functions */\\n\\n    function isOnline() external view returns (bool status);\\n\\n    function isOffline() external view returns (bool status);\\n\\n    function isShutdown() external view returns (bool status);\\n\\n    function getStatus() external view returns (State status);\\n\\n    function getStartTime() external view returns (uint64 startTime);\\n\\n    function getPowerController()\\n        external\\n        view\\n        returns (address controller);\\n}\\n\\n/// @title PowerSwitch\\n/// @notice This power switch contract receives a uint256 \\n///         to enforce powering a switch only after a particular timestamp.\\n/// @notice Standalone pausing and emergency stop functionality\\ncontract PowerSwitch is IPowerSwitch, Ownable {\\n    /* storage */\\n\\n    uint64 private _startTimestamp;\\n    IPowerSwitch.State private _status;\\n\\n    error PowerSwitch_CannotPowerOn();\\n    error PowerSwitch_InvalidOwner();\\n    error PowerSwitch_CannotPowerOff();\\n    error PowerSwitch_CannotShutdown();\\n\\n    /* initializer */\\n\\n    constructor(address owner, uint64 startTimestamp) {\\n        // sanity check owner\\n        if (owner == address(0)) {\\n            revert PowerSwitch_InvalidOwner();\\n        }\\n\\n        _startTimestamp = startTimestamp;\\n        // transfer ownership\\n        Ownable.transferOwnership(owner);\\n    }\\n\\n    /* admin functions */\\n\\n    /// @notice Turn Power On\\n    /// access control: only admin\\n    /// state machine: only when offline\\n    /// state scope: only modify _status\\n    /// token transfer: none\\n    function powerOn() external override onlyOwner {\\n        if (_status != IPowerSwitch.State.Offline) {\\n            revert PowerSwitch_CannotPowerOn();\\n        }\\n        _status = IPowerSwitch.State.Online;\\n        emit PowerOn();\\n    }\\n\\n    /// @notice Turn Power Off\\n    /// access control: only admin\\n    /// state machine: only when online\\n    /// state scope: only modify _status\\n    /// token transfer: none\\n    function powerOff() external override onlyOwner {\\n        if (_status != IPowerSwitch.State.Online) {\\n            revert PowerSwitch_CannotPowerOff();\\n        }\\n        _status = IPowerSwitch.State.Offline;\\n        emit PowerOff();\\n    }\\n\\n    /// @notice Shutdown Permanently\\n    /// access control: only admin\\n    /// state machine:\\n    /// - when online or offline\\n    /// - can only be called once\\n    /// state scope: only modify _status\\n    /// token transfer: none\\n    function emergencyShutdown() external override onlyOwner {\\n        if (_status == IPowerSwitch.State.Shutdown) {\\n            revert PowerSwitch_CannotShutdown();\\n        }\\n        _status = IPowerSwitch.State.Shutdown;\\n        emit EmergencyShutdown();\\n    }\\n\\n    /* getter functions */\\n\\n    function isOnline() external view override returns (bool status) {\\n        return _status == State.Online;\\n    }\\n\\n    function isOffline() external view override returns (bool status) {\\n        return _status == State.Offline;\\n    }\\n\\n    function isShutdown() external view override returns (bool status) {\\n        return _status == State.Shutdown;\\n    }\\n\\n    function getStatus()\\n        external\\n        view\\n        override\\n        returns (IPowerSwitch.State status)\\n    {\\n        // if the current timestamp is greater than _startTimestamp or status is not online\\n        // we return the switch' status\\n        if (block.timestamp >= uint256(_startTimestamp) || _status != State.Online) {\\n            return _status;\\n        } else {\\n            return State.NotStarted;\\n        }\\n    }\\n\\n    function getStartTime()\\n        external\\n        view\\n        override\\n        returns (uint64 startTime)\\n    {\\n        return _startTimestamp;\\n    }\\n\\n    function getPowerController()\\n        external\\n        view\\n        override\\n        returns (address controller)\\n    {\\n        return Ownable.owner();\\n    }\\n}\",\"keccak256\":\"0x1edff82644eb4bcef5384eb91e4039f5cf37c82b096ebac515c2df6fd1e127a5\",\"license\":\"GPL-3.0-only\"},\"src/contracts/powerSwitch/Powered.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.4;\\n\\nimport {IPowerSwitch} from \\\"./PowerSwitch.sol\\\";\\n\\ninterface IPowered {\\n    function isOnline() external view returns (bool status);\\n\\n    function isOffline() external view returns (bool status);\\n\\n    function isShutdown() external view returns (bool status);\\n\\n    function isStarted() external view returns (bool status);\\n\\n    function getPowerSwitch() external view returns (address powerSwitch);\\n\\n    function getPowerController()\\n        external\\n        view\\n        returns (address controller);\\n}\\n\\n/// @title Powered\\n/// @notice Helper for calling external PowerSwitch\\ncontract Powered is IPowered {\\n    /* storage */\\n\\n    address private _powerSwitch;\\n\\n    /* errors */\\n\\n    error Powered_NotOnline();\\n    error Powered_NotOffline();\\n    error Powered_IsShutdown();\\n    error Powered_NotShutdown();\\n    error Powered_NotStarted();\\n\\n    /* modifiers */\\n\\n    modifier onlyOnline() {\\n        _onlyOnline();\\n        _;\\n    }\\n\\n    modifier onlyOffline() {\\n        _onlyOffline();\\n        _;\\n    }\\n\\n    modifier notShutdown() {\\n        _notShutdown();\\n        _;\\n    }\\n\\n    modifier onlyShutdown() {\\n        _onlyShutdown();\\n        _;\\n    }\\n\\n    modifier hasStarted() {\\n        _hasStarted();\\n        _;\\n    }\\n\\n    /* initializer */\\n\\n    function _setPowerSwitch(address powerSwitch) internal {\\n        _powerSwitch = powerSwitch;\\n    }\\n\\n    /* getter functions */\\n\\n    function isOnline() public view override returns (bool status) {\\n        return IPowerSwitch(_powerSwitch).isOnline();\\n    }\\n\\n    function isOffline() public view override returns (bool status) {\\n        return IPowerSwitch(_powerSwitch).isOffline();\\n    }\\n\\n    function isShutdown() public view override returns (bool status) {\\n        return IPowerSwitch(_powerSwitch).isShutdown();\\n    }\\n\\n    function isStarted() public view override returns (bool status) {\\n        return IPowerSwitch(_powerSwitch).getStatus() != IPowerSwitch.State.NotStarted;\\n    }\\n\\n    function getPowerSwitch()\\n        public\\n        view\\n        override\\n        returns (address powerSwitch)\\n    {\\n        return _powerSwitch;\\n    }\\n\\n    function getPowerController()\\n        public\\n        view\\n        override\\n        returns (address controller)\\n    {\\n        return IPowerSwitch(_powerSwitch).getPowerController();\\n    }\\n\\n    /* convenience functions */\\n\\n    function _onlyOnline() private view {\\n        if (!isOnline()) {\\n            revert Powered_NotOnline();\\n        }\\n    }\\n\\n    function _onlyOffline() private view {\\n        if (!isOffline()) {\\n            revert Powered_NotOffline();\\n        }\\n    }\\n\\n    function _notShutdown() private view {\\n        if (isShutdown()) {\\n            revert Powered_IsShutdown();\\n        }\\n    }\\n\\n    function _onlyShutdown() private view {\\n        if (!isShutdown()) {\\n            revert Powered_NotShutdown();\\n        }\\n    }\\n\\n    function _hasStarted() private view {\\n        if (!isStarted()) {\\n            revert Powered_NotStarted();\\n        }\\n    }\\n}\",\"keccak256\":\"0x3d907dbe93ab5f0924c6c540c84d01087a30bf399b0446a18bea1c63ce505ddd\",\"license\":\"GPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x6080806040523461005b5760008054336001600160a01b0319821681178355916001600160a01b03909116907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3612c5a90816100618239f35b600080fdfe6080604052600436101561001257600080fd5b6000803560e01c80623f07fa14611bc25780624414df14611ba657806301210a18146118405780630513247b146117b65780630b2c5c14146117985780632857edd4146116ea5780632ee0b2bc146116605780633e12170f1461144a57806342c026c71461142b578063438cae7e146113ac5780634dd878d91461138d578063544736e61461137257806356360f71146112b85780635d0cde971461129c5780636421945014611278578063643cd8781461125a578063664ab18e1461123f57806371406a3214611223578063715018a6146111c4578063766f13bc146111375780637df98acf146110c05780638382840c1461106c5780638531a636146110435780638539a69a146110165780638da5cb5b14610fef5780638e0ef63614610f3d57806399493c5114610f055780639a793b3c146109e5578063a65e2cfd14610763578063b0ccbf8c14610644578063b3173f9f14610599578063bf86d69014610574578063c25b6b011461054a578063c85dd02514610369578063e2bb9c0f1461034b578063f2fde38b146102b25763f9039437146101b257600080fd5b34610286576060366003190112610286576101cb611be6565b906101d4611bfc565b81546001600160a01b039391906101ee9085163314611d68565b6101f6612bc4565b6101ff81612a73565b8360035416938083169485146102995784845260106020526040842054610299578394506004541691823b15610294576040516323e5d69960e21b81526001600160a01b0391821660048201529116602482015260448035908201529082908290606490829084905af18015610289576102765750f35b61027f90611c84565b6102865780f35b80fd5b6040513d84823e3d90fd5b505050fd5b604051634726455360e11b815260048101869052602490fd5b5034610286576020366003190112610286576102cc611be6565b81546001600160a01b03906102e49082163314611d68565b8116156102f7576102f490611db3565b80f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608490fd5b50346102865780600319360112610286576020600f54604051908152f35b50346102865780600319360112610286576101209060608260405161038d81611cb2565b8381528360208201528360408201526040516103a881611c97565b848152846020820152846040820152838201528360808201528360a08201528360c08201528360e0820152836101008201520152604051906103e982611cb2565b6002546001600160a01b039081168352600354811660208401526004541660408301526104146120f0565b6060830152600854608083015260095460a0830152600a5460c0830152600b5460e0830152600c546001600160a01b0316610100830152610453612114565b8284015260408051602080825284516001600160a01b0390811682840152818601518116838501528386015116606080840191909152850151805160808401529081015160a08301529091015160c0820152928392608081015160e085015260a081015161010085015260c08101518285015260e081015161014085015260018060a01b0361010082015116610160850152015190610180808401526101a08301825180915260206101c085019301915b818110610512575050500390f35b91935091602060608261053c60019488516040809180518452602081015160208501520151910152565b019401910191849392610504565b5034610286576060366003190112610286576102f4610567611be6565b60443590602435906127dc565b5034610286578060031936011261028657602061058f612af6565b6040519015158152f35b5034610286576080366003190112610286576004356001600160401b0381116106405736602382011215610640578060040135916105d683611cef565b906105e46040519283611cce565b8382526020928383019060246060809702820101923684116102865750602401905b8282106106285784610620606435604435602435886122db565b604051908152f35b8486916106353685611d06565b815201910190610606565b5080fd5b5034610286578060031936011261028657338152600e6020526040812060019081810190815415610751576106d96106df926106c7610682426121a8565b600a81905542600b55935460408051338152602081018390527f0f5bb82176feb1b5e747e28471aa92156a04d9f3ab9f45f28e2d704232b93f759190a16009546122bb565b6009556106d44291612204565b61226e565b906122bb565b600a55338252600e602052806040832060008155019081549183815582610704578380f35b6001600160ff1b038316830361073d5783526020832091811b8201915b82811061072c578380f35b600080825582820155600201610721565b634e487b7160e01b84526011600452602484fd5b604051632cdb939b60e21b8152600490fd5b50346102865760403660031901126102865760043560243560018060a01b03610790818554163314611d68565b610798612bc4565b81156109d3576107d5601354936107c46127106107bc61ffff8860a01c16846122c8565b0480926122bb565b948380600354169116903390612450565b60085480156109a0578160035416602083600454166024604051809481936370a0823160e01b835260048301525afa90811561099557869161095d575b506108296108309161082487856122c8565b61238b565b80926121d9565b6008556040519061084082611c97565b8382526020820142815260408301918252600d54600160401b811015610949576001810180600d558110156109355793604095937fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb76109279489979460037fd1652c5efcfb913fe86636bfe9bb19ebb9dd32519e48bb69ffc880e5c2637e1d9b96600d8e52029351847fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb50155517fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb68401555191015580600354169060045416903390612450565b82519182526020820152a180f35b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b90506020813d821161098d575b8161097760209383611cce565b810103126109885751610829610812565b600080fd5b3d915061096a565b6040513d88823e3d90fd5b620f42408085029085820414851517156109bf576108309080926121d9565b634e487b7160e01b86526011600452602486fd5b604051637616640160e01b8152600490fd5b5034610286576080366003190112610286576109ff611be6565b6001600160401b0390602435828111610ea857610a20903690600401611d38565b90604435848111610f0157610a39903690600401611d38565b95909460643590811161064057610a54903690600401611c26565b9590610a5e612bc4565b610a66612c03565b6001600160a01b0386168352600e6020526040832091610a85426121a8565b600a5542600b55600354600480546040516370a0823160e01b81526001600160a01b039182169281019290925290969160209188916024918391165afa958615610ef6578596610ebe575b5090610afc610b0492610af49b9499979b428d60085490610aef612114565b6122db565b98369161278e565b92369161278e565b949783948497859886905b8551821015610dc7579089610b618796959493610b5a848f610b4e8d610b45610b549360019f86610b3f9161225a565b516122bb565b9d8e9101612737565b506121e6565b9461225a565b51906121d9565b9b8b610b6f8484519261225a565b5111610db5578b8251610b82858361225a565b5103610d70575060018901546000199890898101908111610d5c57610bad610bb89160018d01612737565b509160018c01612737565b919091610d4857808203610d34575b505060018101809111610d20579660018901548015610d0c5701610bee8160018b01612737565b610cf6576001816000809355015560018901555b600c546001600160a01b031680610c8b575b506020810151610c2490426122bb565b9d8e9151600a549283610c356120f0565b91610c4093856123ab565b9a8b610c4b916121d9565b9a610c55916122bb565b9d610c60838d61225a565b5190610c6b916122c8565b610c74916122bb565b600a55610c8090611f92565b909192939499610b0f565b803b15610cf257898091604460405180948193636291613960e11b835287516004840152602088015160248401525af18015610ce757908a91610ccf575b50610c14565b610cd890611c84565b610ce3578838610cc9565b8880fd5b6040513d8c823e3d90fd5b8980fd5b634e487b7160e01b600052600060045260246000fd5b634e487b7160e01b8b52603160045260248bfd5b634e487b7160e01b8a52601160045260248afd5b600181819254845501549101553880610bc7565b634e487b7160e01b8c5260048c905260248cfd5b634e487b7160e01b8c52601160045260248cfd5b610d8e610d8385610d97939b949b61225a565b519260018c01612737565b509182546122bb565b9055610dae610da6838d61225a565b5182516122bb565b8152610c02565b60405163083c16bb60e21b8152600490fd5b95919050879394508a8615610eac5782610de3888a95546122bb565b9055610df1876009546122bb565b6009556002546001600160a01b03908116919085163b15610ea85760405163abee080360e01b815292849284928392610e2f928c9060048601612753565b0381836001600160a01b0388165af1801561028957610e90575b5050604080516001600160a01b038316815260208101959095526102f4947f0f5bb82176feb1b5e747e28471aa92156a04d9f3ab9f45f28e2d704232b93f759190a16127dc565b610e9990611c84565b610ea4578486610e49565b8480fd5b8380fd5b6040516316d7d4d560e31b8152600490fd5b919095506020823d602011610eee575b81610edb60209383611cce565b8101031261098857905194610afc610ad0565b3d9150610ece565b6040513d87823e3d90fd5b8580fd5b5034610286576020366003190112610286576020610f24600435611f5b565b905460405160039290921b1c6001600160a01b03168152f35b503461028657602036600319011261028657610f57611be6565b81546001600160a01b039190610f709083163314611d68565b610f78612bc4565b610f8181612a73565b6032600f541015610fdd5716610f9681612614565b15610fc95760207fbca954c637e20d265d501f3c0c9d0df1440001376c36ac73bd296c1a628f528c91604051908152a180f35b634e487b7160e01b82526001600452602482fd5b6040516369fac31360e11b8152600490fd5b5034610286578060031936011261028657546040516001600160a01b039091168152602090f35b503461028657606036600319011261028657602061062060043561103e6024356044356122bb565b6122c8565b50346102865780600319360112610286576001546040516001600160a01b039091168152602090f35b50346102865760e036600319011261028657606036608319011261098857602061062060405161109b81611c97565b608435815260a4358382015260c43560408201526064356044356024356004356123ab565b50346102865780600319360112610286576110d9611e5d565b80611121575b6110e65780f35b805460ff60a81b19168155604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a180f35b815460ff60a81b1916600160a81b1782556110df565b5034610286578060031936011261028657600154604051631d9bc4ef60e21b8152906001600160a01b03906020908390600490829085165afa9182156111b9576020939261118a575b5060405191168152f35b6111ab919250833d81116111b2575b6111a38183611cce565b810190611ea6565b9038611180565b503d611199565b6040513d85823e3d90fd5b5034610286578060031936011261028657600060018060a01b036111ec818454163314611d68565b81546001600160a01b031981168355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b50346102865780600319360112610286576020604051601e8152f35b5034610286578060031936011261028657602061058f612aa6565b50346102865780600319360112610286576020601154604051908152f35b503461028657602036600319011261028657602061058f611297611be6565b611fcf565b5034610286578060031936011261028657602060405160328152f35b50346102865760208060031936011261064057906112d4611be6565b6060836040516112e381611c53565b84815201526001600160a01b03168152600e8252604080822090519161130883611c53565b815483526113196001809301612204565b9284810193845260405193858552606085019151868601525194604080860152855180925280608086019601925b8281106113545785870386f35b83518051885282015182880152604090960195928101928401611347565b5034610286578060031936011261028657602061058f612b2e565b5034610286576020366003190112610286576020610f24600435611f0e565b50346102865780600319360112610286576001546040516321c6573f60e11b815290602090829060049082906001600160a01b03165afa90811561028957602092916113fe575b506040519015158152f35b61141e9150823d8111611424575b6114168183611cce565b810190611fb7565b386113f3565b503d61140c565b50346102865760203660031901126102865760206106206004356121a8565b503461028657606036600319011261028657611464611be6565b906024356044356001600160401b03811161165c57611487903690600401611c26565b90611490612bc4565b611498612c03565b6114a185611fcf565b1561164a578215611638576001600160a01b03858116808652600e60205260408620600181018054929392601e1115611626576114dd426121a8565b600a5542600b55604051906114f182611c53565b8782526020820190428252805490600160401b821015611612579061151b91600182018155612737565b9290926115fe5790600191518355519101556115388682546121d9565b9055611546856009546121d9565b60095560025416813b15610f015790848680949361157a6040519788968795869463c792f45d60e01b865260048601612753565b03925af180156111b9576115cd575b50604080516001600160a01b03949094168452602084019190915290917f9e71bc8eea02a63969f509818f2dafb9254532904319f9dbda79b67bd34a5f3d9190a180f35b916115f87f9e71bc8eea02a63969f509818f2dafb9254532904319f9dbda79b67bd34a5f3d93611c84565b91611589565b634e487b7160e01b8a5260048a905260248afd5b634e487b7160e01b8b52604160045260248bfd5b604051630c23778b60e11b8152600490fd5b604051637e6e0ea960e01b8152600490fd5b604051630681d31960e51b8152600490fd5b8280fd5b50346102865760203660031901126102865761167a611be6565b81546001600160a01b0391906116939083163314611d68565b61169b612be4565b166116a581612595565b156116d85760207f059b5054f04b000050b3cbdf0ad2d8bce0dfca886836a4742ab837cc948cd1af91604051908152a180f35b6040516324ec133760e11b8152600490fd5b5034610286576040366003190112610286576004356001600160401b03811161064057366023820112156106405780600401359061172782611cef565b906117356040519283611cce565b82825260209260248484019160061b83010191368311610f0157602401905b82821061176857846106206024358661226e565b604082360312610f015784604091825161178181611c53565b843581528285013583820152815201910190611754565b50346102865780600319360112610286576020604051620f42408152f35b5034610286576020366003190112610286576117d0611be6565b81546001600160a01b0391906117e99083163314611d68565b6117f1612be4565b166117fb81612661565b1561182e5760207f040b321f0ccd1b9d7890282c99da1d97cbf2de30c3af0782aba31fbd9528324391604051908152a180f35b604051631a8a3d2f60e01b8152600490fd5b50346102865760a0366003190112610286576004356001600160401b039081811680910361165c57611870611bfc565b6001600160a01b039290919060443584811690819003610f01576064359361ffff85168503611ba257608435838111611b9e576118b1903690600401611c26565b9590966118bc611e5d565b9687611b88575b880161010089820312610cf2576040519560c0870190811187821017611612576040526118ef89611c12565b86526020986118ff8a8201611c12565b968a810197885261191260408301611c12565b946040820195865261192660608401611c12565b92606083019384526080810135948686168603611b845760a0611950926080860197885201611d06565b9060a0830198828a526013549161ffff60a01b9060a01b169169ffffffffffffffffffff60b01b1617176013558b815191015110611b725760408751015115611b6057838c985116988460405197168c8801526040870152604086526119b586611c97565b8a604051809a818b816119d663cf5ba53f60e01b9c8d835260048301611ec5565b03925af18015611b5557848c92611a1e9b8b93611b36575b505116856040519216978884840152838352611a0983611c53565b8a604051809d81958294835260048301611ec5565b03925af1978815611b2b577f9848123ba141e26644059f3993427b10fe045ef81a9f876a081652b36fe85f0b98846040999381938e8c9694611b0c575b5050611a6633611db3565b816bffffffffffffffffffffffff60a01b988a8a6001541617600155511688600254161760025551168660035416176003551695868560045416176004555180516005558a8101516006550151600755511690600c541617600c55825191825285820152a1611ad3575080f35b815460ff60a81b19168255604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989190a180f35b611b23929450803d106111b2576111a38183611cce565b91388e611a5b565b6040513d89823e3d90fd5b611b4e919350843d86116111b2576111a38183611cce565b91386119ee565b6040513d8a823e3d90fd5b604051638c648c8560e01b8152600490fd5b6040516318084af360e01b8152600490fd5b8e80fd5b895460ff60a81b1916600160a81b178a556118c3565b8780fd5b8680fd5b50346102865780600319360112610286576020610620426121a8565b503461028657602036600319011261028657602061058f611be1611be6565b612073565b600435906001600160a01b038216820361098857565b602435906001600160a01b038216820361098857565b35906001600160a01b038216820361098857565b9181601f84011215610988578235916001600160401b038311610988576020838186019501011161098857565b604081019081106001600160401b03821117611c6e57604052565b634e487b7160e01b600052604160045260246000fd5b6001600160401b038111611c6e57604052565b606081019081106001600160401b03821117611c6e57604052565b61014081019081106001600160401b03821117611c6e57604052565b90601f801991011681019081106001600160401b03821117611c6e57604052565b6001600160401b038111611c6e5760051b60200190565b919082606091031261098857604051611d1e81611c97565b604080829480358452602081013560208501520135910152565b9181601f84011215610988578235916001600160401b038311610988576020808501948460051b01011161098857565b15611d6f57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600080546001600160a01b039283166001600160a01b03198216811783559216907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3565b15611e0157565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b60005460ff8160a81c16600014611e7f5750611e7a303b15611dfa565b600090565b611e91600160ff8360a01c1610611dfa565b60ff60a01b1916600160a01b17600055600190565b9081602091031261098857516001600160a01b03811681036109885790565b6020808252825181830181905290939260005b828110611efa57505060409293506000838284010152601f8019910116010190565b818101860151848201604001528501611ed8565b600f54811015611f4557600f6000527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac8020190600090565b634e487b7160e01b600052603260045260246000fd5b601154811015611f455760116000527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c680190600090565b6000198114611fa15760010190565b634e487b7160e01b600052601160045260246000fd5b90816020910312610988575180151581036109885790565b6011549060005b828110611fe557505050600090565b611fee81611f5b565b9054906040918251916335a2735f60e11b83528260248160018060a01b03808a166004830152602095869560031b1c165afa928315612069575060009261204c575b50506120445761203f90611f92565b611fd6565b505050600190565b6120629250803d10611424576114168183611cce565b3880612030565b513d6000823e3d90fd5b6001600160a01b039081163081141591826120e6575b826120d7575b826120c8575b826120b9575b50816120a5575090565b905060005260106020526040600020541590565b6004541681141591503861209b565b60035481168214159250612095565b6002548116821415925061208f565b8115159250612089565b604051906120fd82611c97565b600554825260065460208301526007546040830152565b600d549061212182611cef565b91604061213081519485611cce565b81845283602080910191600d6000527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5906000935b85851061217457505050505050565b600384600192845161218581611c97565b865481528487015483820152600287015486820152815201930194019391612165565b600b548082146121d1576121ce9161103e6121c692600954926122bb565b600a546121d9565b90565b5050600a5490565b91908201809211611fa157565b906040516121f381611c53565b602060018294805484520154910152565b90815461221081611cef565b9261221e6040519485611cce565b818452600090815260208082208186015b84841061223d575050505050565b60028360019261224c856121e6565b81520192019301929061222f565b8051821015611f455760209160051b010190565b6000929190835b81518510156122b5576122a96122af916122a3612292888661225a565b5161103e60208251920151886122bb565b906121d9565b94611f92565b93612275565b93505050565b91908203918211611fa157565b81810292918115918404141715611fa157565b9392919284511561238157600091825b86518410156123685761232961232f91612305868a61225a565b5190600091602081019061231a82518b6122bb565b815111612335575b50506121d9565b93611f92565b926122eb565b6123609293508061235861235260406106d994015194518d6122bb565b846122c8565b90519061238b565b903880612322565b6121ce959296508194506106d9935090610824916122c8565b9350505050600090565b8115612395570490565b634e487b7160e01b600052601260045260246000fd5b939290826123b8916122c8565b60009482612437575b505050604082019182518210801590612429575b156123e05750505090565b916123586122a392612358856124236124186124016121ce9a99518a6122c8565b94612412602085019687519061238b565b996122c8565b9184519051906122bb565b906122c8565b5080516020820151146123d5565b61244793955090610824916122c8565b913880806123c1565b6040516323b872dd60e01b60208083019182526001600160a01b0394851660248401529490931660448201526064808201959095529384529192601f1992919061249b608482611cce565b600092839283809351925af1913d1561258c573d6001600160401b038111612578576124d18560405193601f8401160183611cce565b81528091843d92013e5b81612548575b50156124ea5750565b6084906040519062461bcd60e51b82526004820152603160248201527f5472616e7366657248656c7065723a3a7472616e7366657246726f6d3a207472604482015270185b9cd9995c919c9bdb4819985a5b1959607a1b6064820152fd5b80518015925083908315612560575b505050386124e1565b6125709350820181019101611fb7565b388281612557565b634e487b7160e01b83526041600452602483fd5b505060606124db565b60008181526012602052604081205461260f57601154600160401b8110156125fb5790826125e76125ce84600160409601601155611f5b565b819391549060031b600019811b9283911b169119161790565b905560115492815260126020522055600190565b634e487b7160e01b82526041600452602482fd5b905090565b60008181526010602052604081205461260f57600f54600160401b8110156125fb57908261264d6125ce84600160409601600f55611f0e565b9055600f5492815260106020522055600190565b6000818152601260205260408120549091908015612732576000199080820181811161271e57601154908382019182116109bf578082036126ea575b50505060115480156126d6578101906126b582611f5b565b909182549160031b1b19169055601155815260126020526040812055600190565b634e487b7160e01b84526031600452602484fd5b6127086126f96125ce93611f5b565b90549060031b1c928392611f5b565b905584526012602052604084205538808061269d565b634e487b7160e01b85526011600452602485fd5b505090565b8054821015611f455760005260206000209060011b0190600090565b9284926080959260018060a01b03168552602085015260606040850152816060850152848401376000828201840152601f01601f1916010190565b929161279982611cef565b916127a76040519384611cce565b829481845260208094019160051b810192831161098857905b8282106127cd5750505050565b813581529083019083016127c0565b91816127e757505050565b6127fb6008546106d98361082486846122c8565b600855600f9081546128e1575b50506004546003546001600160a01b0390811693918116803b15610988576040516323e5d69960e21b81526001600160a01b0395861660048201529483166024860152604485018490526000908590606490829084905af19081156128d5577f0aa4d283470c904c551d18bb894d37e17674920f3261a7f854be501e25f421b7946128c1926128c6575b5060035416926040519384938460409194939294606082019560018060a01b0380921683521660208201520152565b0390a1565b6128cf90611c84565b38612892565b6040513d6000823e3d90fd5b919360009391935b8454811015612a66576128fb81611f0e565b9060018060a01b03918291549060031b1c166004918254169160409081516370a0823160e01b815284828201526020908181602481885afa918215612a5b57918a918d93600092612a24575b505061295692610824916122c8565b93803b156109885782516323e5d69960e21b81526001600160a01b03808616938201938452891660208401526040830186905291600091839182908490829060600103925af18015612a1957612a059594927f0aa4d283470c904c551d18bb894d37e17674920f3261a7f854be501e25f421b794926129fd92612a0a575b50516001600160a01b03808a168252909216602083015260408201929092529081906060820190565b0390a1611f92565b6128e9565b612a1390611c84565b386129d4565b82513d6000823e3d90fd5b819450809293503d8311612a54575b612a3d8183611cce565b810103126102865750518a90899082610824612947565b503d612a33565b84513d6000823e3d90fd5b5093915091503880612808565b612a7c81612073565b15612a845750565b604051634726455360e11b81526001600160a01b039091166004820152602490fd5b60015460405163332558c760e11b815290602090829060049082906001600160a01b03165afa9081156128d557600091612ade575090565b6121ce915060203d8111611424576114168183611cce565b600154604051630bf86d6960e41b815290602090829060049082906001600160a01b03165afa9081156128d557600091612ade575090565b6001546040516302734eab60e51b815290602090829060049082906001600160a01b03165afa9081156128d557600091612b8a575b506004811015612b74576003141590565b634e487b7160e01b600052602160045260246000fd5b6020813d8211612bbc575b81612ba260209383611cce565b810103126106405751906004821015610286575038612b63565b3d9150612b95565b612bcc612aa6565b15612bd357565b604051623ff97760e91b8152600490fd5b612bec612af6565b612bf257565b6040516289a30f60e01b8152600490fd5b612c0b612b2e565b15612c1257565b604051631c775e9960e21b8152600490fdfea2646970667358221220912a80cd02e3a7ea73e559d2d1294b316070896b0223612f54139d8f17e35fa464736f6c63430008110033",
  "deployedBytecode": "0x6080604052600436101561001257600080fd5b6000803560e01c80623f07fa14611bc25780624414df14611ba657806301210a18146118405780630513247b146117b65780630b2c5c14146117985780632857edd4146116ea5780632ee0b2bc146116605780633e12170f1461144a57806342c026c71461142b578063438cae7e146113ac5780634dd878d91461138d578063544736e61461137257806356360f71146112b85780635d0cde971461129c5780636421945014611278578063643cd8781461125a578063664ab18e1461123f57806371406a3214611223578063715018a6146111c4578063766f13bc146111375780637df98acf146110c05780638382840c1461106c5780638531a636146110435780638539a69a146110165780638da5cb5b14610fef5780638e0ef63614610f3d57806399493c5114610f055780639a793b3c146109e5578063a65e2cfd14610763578063b0ccbf8c14610644578063b3173f9f14610599578063bf86d69014610574578063c25b6b011461054a578063c85dd02514610369578063e2bb9c0f1461034b578063f2fde38b146102b25763f9039437146101b257600080fd5b34610286576060366003190112610286576101cb611be6565b906101d4611bfc565b81546001600160a01b039391906101ee9085163314611d68565b6101f6612bc4565b6101ff81612a73565b8360035416938083169485146102995784845260106020526040842054610299578394506004541691823b15610294576040516323e5d69960e21b81526001600160a01b0391821660048201529116602482015260448035908201529082908290606490829084905af18015610289576102765750f35b61027f90611c84565b6102865780f35b80fd5b6040513d84823e3d90fd5b505050fd5b604051634726455360e11b815260048101869052602490fd5b5034610286576020366003190112610286576102cc611be6565b81546001600160a01b03906102e49082163314611d68565b8116156102f7576102f490611db3565b80f35b60405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201526564647265737360d01b6064820152608490fd5b50346102865780600319360112610286576020600f54604051908152f35b50346102865780600319360112610286576101209060608260405161038d81611cb2565b8381528360208201528360408201526040516103a881611c97565b848152846020820152846040820152838201528360808201528360a08201528360c08201528360e0820152836101008201520152604051906103e982611cb2565b6002546001600160a01b039081168352600354811660208401526004541660408301526104146120f0565b6060830152600854608083015260095460a0830152600a5460c0830152600b5460e0830152600c546001600160a01b0316610100830152610453612114565b8284015260408051602080825284516001600160a01b0390811682840152818601518116838501528386015116606080840191909152850151805160808401529081015160a08301529091015160c0820152928392608081015160e085015260a081015161010085015260c08101518285015260e081015161014085015260018060a01b0361010082015116610160850152015190610180808401526101a08301825180915260206101c085019301915b818110610512575050500390f35b91935091602060608261053c60019488516040809180518452602081015160208501520151910152565b019401910191849392610504565b5034610286576060366003190112610286576102f4610567611be6565b60443590602435906127dc565b5034610286578060031936011261028657602061058f612af6565b6040519015158152f35b5034610286576080366003190112610286576004356001600160401b0381116106405736602382011215610640578060040135916105d683611cef565b906105e46040519283611cce565b8382526020928383019060246060809702820101923684116102865750602401905b8282106106285784610620606435604435602435886122db565b604051908152f35b8486916106353685611d06565b815201910190610606565b5080fd5b5034610286578060031936011261028657338152600e6020526040812060019081810190815415610751576106d96106df926106c7610682426121a8565b600a81905542600b55935460408051338152602081018390527f0f5bb82176feb1b5e747e28471aa92156a04d9f3ab9f45f28e2d704232b93f759190a16009546122bb565b6009556106d44291612204565b61226e565b906122bb565b600a55338252600e602052806040832060008155019081549183815582610704578380f35b6001600160ff1b038316830361073d5783526020832091811b8201915b82811061072c578380f35b600080825582820155600201610721565b634e487b7160e01b84526011600452602484fd5b604051632cdb939b60e21b8152600490fd5b50346102865760403660031901126102865760043560243560018060a01b03610790818554163314611d68565b610798612bc4565b81156109d3576107d5601354936107c46127106107bc61ffff8860a01c16846122c8565b0480926122bb565b948380600354169116903390612450565b60085480156109a0578160035416602083600454166024604051809481936370a0823160e01b835260048301525afa90811561099557869161095d575b506108296108309161082487856122c8565b61238b565b80926121d9565b6008556040519061084082611c97565b8382526020820142815260408301918252600d54600160401b811015610949576001810180600d558110156109355793604095937fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb76109279489979460037fd1652c5efcfb913fe86636bfe9bb19ebb9dd32519e48bb69ffc880e5c2637e1d9b96600d8e52029351847fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb50155517fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb68401555191015580600354169060045416903390612450565b82519182526020820152a180f35b634e487b7160e01b88526032600452602488fd5b634e487b7160e01b88526041600452602488fd5b90506020813d821161098d575b8161097760209383611cce565b810103126109885751610829610812565b600080fd5b3d915061096a565b6040513d88823e3d90fd5b620f42408085029085820414851517156109bf576108309080926121d9565b634e487b7160e01b86526011600452602486fd5b604051637616640160e01b8152600490fd5b5034610286576080366003190112610286576109ff611be6565b6001600160401b0390602435828111610ea857610a20903690600401611d38565b90604435848111610f0157610a39903690600401611d38565b95909460643590811161064057610a54903690600401611c26565b9590610a5e612bc4565b610a66612c03565b6001600160a01b0386168352600e6020526040832091610a85426121a8565b600a5542600b55600354600480546040516370a0823160e01b81526001600160a01b039182169281019290925290969160209188916024918391165afa958615610ef6578596610ebe575b5090610afc610b0492610af49b9499979b428d60085490610aef612114565b6122db565b98369161278e565b92369161278e565b949783948497859886905b8551821015610dc7579089610b618796959493610b5a848f610b4e8d610b45610b549360019f86610b3f9161225a565b516122bb565b9d8e9101612737565b506121e6565b9461225a565b51906121d9565b9b8b610b6f8484519261225a565b5111610db5578b8251610b82858361225a565b5103610d70575060018901546000199890898101908111610d5c57610bad610bb89160018d01612737565b509160018c01612737565b919091610d4857808203610d34575b505060018101809111610d20579660018901548015610d0c5701610bee8160018b01612737565b610cf6576001816000809355015560018901555b600c546001600160a01b031680610c8b575b506020810151610c2490426122bb565b9d8e9151600a549283610c356120f0565b91610c4093856123ab565b9a8b610c4b916121d9565b9a610c55916122bb565b9d610c60838d61225a565b5190610c6b916122c8565b610c74916122bb565b600a55610c8090611f92565b909192939499610b0f565b803b15610cf257898091604460405180948193636291613960e11b835287516004840152602088015160248401525af18015610ce757908a91610ccf575b50610c14565b610cd890611c84565b610ce3578838610cc9565b8880fd5b6040513d8c823e3d90fd5b8980fd5b634e487b7160e01b600052600060045260246000fd5b634e487b7160e01b8b52603160045260248bfd5b634e487b7160e01b8a52601160045260248afd5b600181819254845501549101553880610bc7565b634e487b7160e01b8c5260048c905260248cfd5b634e487b7160e01b8c52601160045260248cfd5b610d8e610d8385610d97939b949b61225a565b519260018c01612737565b509182546122bb565b9055610dae610da6838d61225a565b5182516122bb565b8152610c02565b60405163083c16bb60e21b8152600490fd5b95919050879394508a8615610eac5782610de3888a95546122bb565b9055610df1876009546122bb565b6009556002546001600160a01b03908116919085163b15610ea85760405163abee080360e01b815292849284928392610e2f928c9060048601612753565b0381836001600160a01b0388165af1801561028957610e90575b5050604080516001600160a01b038316815260208101959095526102f4947f0f5bb82176feb1b5e747e28471aa92156a04d9f3ab9f45f28e2d704232b93f759190a16127dc565b610e9990611c84565b610ea4578486610e49565b8480fd5b8380fd5b6040516316d7d4d560e31b8152600490fd5b919095506020823d602011610eee575b81610edb60209383611cce565b8101031261098857905194610afc610ad0565b3d9150610ece565b6040513d87823e3d90fd5b8580fd5b5034610286576020366003190112610286576020610f24600435611f5b565b905460405160039290921b1c6001600160a01b03168152f35b503461028657602036600319011261028657610f57611be6565b81546001600160a01b039190610f709083163314611d68565b610f78612bc4565b610f8181612a73565b6032600f541015610fdd5716610f9681612614565b15610fc95760207fbca954c637e20d265d501f3c0c9d0df1440001376c36ac73bd296c1a628f528c91604051908152a180f35b634e487b7160e01b82526001600452602482fd5b6040516369fac31360e11b8152600490fd5b5034610286578060031936011261028657546040516001600160a01b039091168152602090f35b503461028657606036600319011261028657602061062060043561103e6024356044356122bb565b6122c8565b50346102865780600319360112610286576001546040516001600160a01b039091168152602090f35b50346102865760e036600319011261028657606036608319011261098857602061062060405161109b81611c97565b608435815260a4358382015260c43560408201526064356044356024356004356123ab565b50346102865780600319360112610286576110d9611e5d565b80611121575b6110e65780f35b805460ff60a81b19168155604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb384740249890602090a180f35b815460ff60a81b1916600160a81b1782556110df565b5034610286578060031936011261028657600154604051631d9bc4ef60e21b8152906001600160a01b03906020908390600490829085165afa9182156111b9576020939261118a575b5060405191168152f35b6111ab919250833d81116111b2575b6111a38183611cce565b810190611ea6565b9038611180565b503d611199565b6040513d85823e3d90fd5b5034610286578060031936011261028657600060018060a01b036111ec818454163314611d68565b81546001600160a01b031981168355167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e08280a380f35b50346102865780600319360112610286576020604051601e8152f35b5034610286578060031936011261028657602061058f612aa6565b50346102865780600319360112610286576020601154604051908152f35b503461028657602036600319011261028657602061058f611297611be6565b611fcf565b5034610286578060031936011261028657602060405160328152f35b50346102865760208060031936011261064057906112d4611be6565b6060836040516112e381611c53565b84815201526001600160a01b03168152600e8252604080822090519161130883611c53565b815483526113196001809301612204565b9284810193845260405193858552606085019151868601525194604080860152855180925280608086019601925b8281106113545785870386f35b83518051885282015182880152604090960195928101928401611347565b5034610286578060031936011261028657602061058f612b2e565b5034610286576020366003190112610286576020610f24600435611f0e565b50346102865780600319360112610286576001546040516321c6573f60e11b815290602090829060049082906001600160a01b03165afa90811561028957602092916113fe575b506040519015158152f35b61141e9150823d8111611424575b6114168183611cce565b810190611fb7565b386113f3565b503d61140c565b50346102865760203660031901126102865760206106206004356121a8565b503461028657606036600319011261028657611464611be6565b906024356044356001600160401b03811161165c57611487903690600401611c26565b90611490612bc4565b611498612c03565b6114a185611fcf565b1561164a578215611638576001600160a01b03858116808652600e60205260408620600181018054929392601e1115611626576114dd426121a8565b600a5542600b55604051906114f182611c53565b8782526020820190428252805490600160401b821015611612579061151b91600182018155612737565b9290926115fe5790600191518355519101556115388682546121d9565b9055611546856009546121d9565b60095560025416813b15610f015790848680949361157a6040519788968795869463c792f45d60e01b865260048601612753565b03925af180156111b9576115cd575b50604080516001600160a01b03949094168452602084019190915290917f9e71bc8eea02a63969f509818f2dafb9254532904319f9dbda79b67bd34a5f3d9190a180f35b916115f87f9e71bc8eea02a63969f509818f2dafb9254532904319f9dbda79b67bd34a5f3d93611c84565b91611589565b634e487b7160e01b8a5260048a905260248afd5b634e487b7160e01b8b52604160045260248bfd5b604051630c23778b60e11b8152600490fd5b604051637e6e0ea960e01b8152600490fd5b604051630681d31960e51b8152600490fd5b8280fd5b50346102865760203660031901126102865761167a611be6565b81546001600160a01b0391906116939083163314611d68565b61169b612be4565b166116a581612595565b156116d85760207f059b5054f04b000050b3cbdf0ad2d8bce0dfca886836a4742ab837cc948cd1af91604051908152a180f35b6040516324ec133760e11b8152600490fd5b5034610286576040366003190112610286576004356001600160401b03811161064057366023820112156106405780600401359061172782611cef565b906117356040519283611cce565b82825260209260248484019160061b83010191368311610f0157602401905b82821061176857846106206024358661226e565b604082360312610f015784604091825161178181611c53565b843581528285013583820152815201910190611754565b50346102865780600319360112610286576020604051620f42408152f35b5034610286576020366003190112610286576117d0611be6565b81546001600160a01b0391906117e99083163314611d68565b6117f1612be4565b166117fb81612661565b1561182e5760207f040b321f0ccd1b9d7890282c99da1d97cbf2de30c3af0782aba31fbd9528324391604051908152a180f35b604051631a8a3d2f60e01b8152600490fd5b50346102865760a0366003190112610286576004356001600160401b039081811680910361165c57611870611bfc565b6001600160a01b039290919060443584811690819003610f01576064359361ffff85168503611ba257608435838111611b9e576118b1903690600401611c26565b9590966118bc611e5d565b9687611b88575b880161010089820312610cf2576040519560c0870190811187821017611612576040526118ef89611c12565b86526020986118ff8a8201611c12565b968a810197885261191260408301611c12565b946040820195865261192660608401611c12565b92606083019384526080810135948686168603611b845760a0611950926080860197885201611d06565b9060a0830198828a526013549161ffff60a01b9060a01b169169ffffffffffffffffffff60b01b1617176013558b815191015110611b725760408751015115611b6057838c985116988460405197168c8801526040870152604086526119b586611c97565b8a604051809a818b816119d663cf5ba53f60e01b9c8d835260048301611ec5565b03925af18015611b5557848c92611a1e9b8b93611b36575b505116856040519216978884840152838352611a0983611c53565b8a604051809d81958294835260048301611ec5565b03925af1978815611b2b577f9848123ba141e26644059f3993427b10fe045ef81a9f876a081652b36fe85f0b98846040999381938e8c9694611b0c575b5050611a6633611db3565b816bffffffffffffffffffffffff60a01b988a8a6001541617600155511688600254161760025551168660035416176003551695868560045416176004555180516005558a8101516006550151600755511690600c541617600c55825191825285820152a1611ad3575080f35b815460ff60a81b19168255604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989190a180f35b611b23929450803d106111b2576111a38183611cce565b91388e611a5b565b6040513d89823e3d90fd5b611b4e919350843d86116111b2576111a38183611cce565b91386119ee565b6040513d8a823e3d90fd5b604051638c648c8560e01b8152600490fd5b6040516318084af360e01b8152600490fd5b8e80fd5b895460ff60a81b1916600160a81b178a556118c3565b8780fd5b8680fd5b50346102865780600319360112610286576020610620426121a8565b503461028657602036600319011261028657602061058f611be1611be6565b612073565b600435906001600160a01b038216820361098857565b602435906001600160a01b038216820361098857565b35906001600160a01b038216820361098857565b9181601f84011215610988578235916001600160401b038311610988576020838186019501011161098857565b604081019081106001600160401b03821117611c6e57604052565b634e487b7160e01b600052604160045260246000fd5b6001600160401b038111611c6e57604052565b606081019081106001600160401b03821117611c6e57604052565b61014081019081106001600160401b03821117611c6e57604052565b90601f801991011681019081106001600160401b03821117611c6e57604052565b6001600160401b038111611c6e5760051b60200190565b919082606091031261098857604051611d1e81611c97565b604080829480358452602081013560208501520135910152565b9181601f84011215610988578235916001600160401b038311610988576020808501948460051b01011161098857565b15611d6f57565b606460405162461bcd60e51b815260206004820152602060248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152fd5b600080546001600160a01b039283166001600160a01b03198216811783559216907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09080a3565b15611e0157565b60405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b6064820152608490fd5b60005460ff8160a81c16600014611e7f5750611e7a303b15611dfa565b600090565b611e91600160ff8360a01c1610611dfa565b60ff60a01b1916600160a01b17600055600190565b9081602091031261098857516001600160a01b03811681036109885790565b6020808252825181830181905290939260005b828110611efa57505060409293506000838284010152601f8019910116010190565b818101860151848201604001528501611ed8565b600f54811015611f4557600f6000527f8d1108e10bcb7c27dddfc02ed9d693a074039d026cf4ea4240b40f7d581ac8020190600090565b634e487b7160e01b600052603260045260246000fd5b601154811015611f455760116000527f31ecc21a745e3968a04e9570e4425bc18fa8019c68028196b546d1669c200c680190600090565b6000198114611fa15760010190565b634e487b7160e01b600052601160045260246000fd5b90816020910312610988575180151581036109885790565b6011549060005b828110611fe557505050600090565b611fee81611f5b565b9054906040918251916335a2735f60e11b83528260248160018060a01b03808a166004830152602095869560031b1c165afa928315612069575060009261204c575b50506120445761203f90611f92565b611fd6565b505050600190565b6120629250803d10611424576114168183611cce565b3880612030565b513d6000823e3d90fd5b6001600160a01b039081163081141591826120e6575b826120d7575b826120c8575b826120b9575b50816120a5575090565b905060005260106020526040600020541590565b6004541681141591503861209b565b60035481168214159250612095565b6002548116821415925061208f565b8115159250612089565b604051906120fd82611c97565b600554825260065460208301526007546040830152565b600d549061212182611cef565b91604061213081519485611cce565b81845283602080910191600d6000527fd7b6990105719101dabeb77144f2a3385c8033acd3af97e9423a695e81ad1eb5906000935b85851061217457505050505050565b600384600192845161218581611c97565b865481528487015483820152600287015486820152815201930194019391612165565b600b548082146121d1576121ce9161103e6121c692600954926122bb565b600a546121d9565b90565b5050600a5490565b91908201809211611fa157565b906040516121f381611c53565b602060018294805484520154910152565b90815461221081611cef565b9261221e6040519485611cce565b818452600090815260208082208186015b84841061223d575050505050565b60028360019261224c856121e6565b81520192019301929061222f565b8051821015611f455760209160051b010190565b6000929190835b81518510156122b5576122a96122af916122a3612292888661225a565b5161103e60208251920151886122bb565b906121d9565b94611f92565b93612275565b93505050565b91908203918211611fa157565b81810292918115918404141715611fa157565b9392919284511561238157600091825b86518410156123685761232961232f91612305868a61225a565b5190600091602081019061231a82518b6122bb565b815111612335575b50506121d9565b93611f92565b926122eb565b6123609293508061235861235260406106d994015194518d6122bb565b846122c8565b90519061238b565b903880612322565b6121ce959296508194506106d9935090610824916122c8565b9350505050600090565b8115612395570490565b634e487b7160e01b600052601260045260246000fd5b939290826123b8916122c8565b60009482612437575b505050604082019182518210801590612429575b156123e05750505090565b916123586122a392612358856124236124186124016121ce9a99518a6122c8565b94612412602085019687519061238b565b996122c8565b9184519051906122bb565b906122c8565b5080516020820151146123d5565b61244793955090610824916122c8565b913880806123c1565b6040516323b872dd60e01b60208083019182526001600160a01b0394851660248401529490931660448201526064808201959095529384529192601f1992919061249b608482611cce565b600092839283809351925af1913d1561258c573d6001600160401b038111612578576124d18560405193601f8401160183611cce565b81528091843d92013e5b81612548575b50156124ea5750565b6084906040519062461bcd60e51b82526004820152603160248201527f5472616e7366657248656c7065723a3a7472616e7366657246726f6d3a207472604482015270185b9cd9995c919c9bdb4819985a5b1959607a1b6064820152fd5b80518015925083908315612560575b505050386124e1565b6125709350820181019101611fb7565b388281612557565b634e487b7160e01b83526041600452602483fd5b505060606124db565b60008181526012602052604081205461260f57601154600160401b8110156125fb5790826125e76125ce84600160409601601155611f5b565b819391549060031b600019811b9283911b169119161790565b905560115492815260126020522055600190565b634e487b7160e01b82526041600452602482fd5b905090565b60008181526010602052604081205461260f57600f54600160401b8110156125fb57908261264d6125ce84600160409601600f55611f0e565b9055600f5492815260106020522055600190565b6000818152601260205260408120549091908015612732576000199080820181811161271e57601154908382019182116109bf578082036126ea575b50505060115480156126d6578101906126b582611f5b565b909182549160031b1b19169055601155815260126020526040812055600190565b634e487b7160e01b84526031600452602484fd5b6127086126f96125ce93611f5b565b90549060031b1c928392611f5b565b905584526012602052604084205538808061269d565b634e487b7160e01b85526011600452602485fd5b505090565b8054821015611f455760005260206000209060011b0190600090565b9284926080959260018060a01b03168552602085015260606040850152816060850152848401376000828201840152601f01601f1916010190565b929161279982611cef565b916127a76040519384611cce565b829481845260208094019160051b810192831161098857905b8282106127cd5750505050565b813581529083019083016127c0565b91816127e757505050565b6127fb6008546106d98361082486846122c8565b600855600f9081546128e1575b50506004546003546001600160a01b0390811693918116803b15610988576040516323e5d69960e21b81526001600160a01b0395861660048201529483166024860152604485018490526000908590606490829084905af19081156128d5577f0aa4d283470c904c551d18bb894d37e17674920f3261a7f854be501e25f421b7946128c1926128c6575b5060035416926040519384938460409194939294606082019560018060a01b0380921683521660208201520152565b0390a1565b6128cf90611c84565b38612892565b6040513d6000823e3d90fd5b919360009391935b8454811015612a66576128fb81611f0e565b9060018060a01b03918291549060031b1c166004918254169160409081516370a0823160e01b815284828201526020908181602481885afa918215612a5b57918a918d93600092612a24575b505061295692610824916122c8565b93803b156109885782516323e5d69960e21b81526001600160a01b03808616938201938452891660208401526040830186905291600091839182908490829060600103925af18015612a1957612a059594927f0aa4d283470c904c551d18bb894d37e17674920f3261a7f854be501e25f421b794926129fd92612a0a575b50516001600160a01b03808a168252909216602083015260408201929092529081906060820190565b0390a1611f92565b6128e9565b612a1390611c84565b386129d4565b82513d6000823e3d90fd5b819450809293503d8311612a54575b612a3d8183611cce565b810103126102865750518a90899082610824612947565b503d612a33565b84513d6000823e3d90fd5b5093915091503880612808565b612a7c81612073565b15612a845750565b604051634726455360e11b81526001600160a01b039091166004820152602490fd5b60015460405163332558c760e11b815290602090829060049082906001600160a01b03165afa9081156128d557600091612ade575090565b6121ce915060203d8111611424576114168183611cce565b600154604051630bf86d6960e41b815290602090829060049082906001600160a01b03165afa9081156128d557600091612ade575090565b6001546040516302734eab60e51b815290602090829060049082906001600160a01b03165afa9081156128d557600091612b8a575b506004811015612b74576003141590565b634e487b7160e01b600052602160045260246000fd5b6020813d8211612bbc575b81612ba260209383611cce565b810103126106405751906004821015610286575038612b63565b3d9150612b95565b612bcc612aa6565b15612bd357565b604051623ff97760e91b8152600490fd5b612bec612af6565b612bf257565b6040516289a30f60e01b8152600490fd5b612c0b612b2e565b15612c1257565b604051631c775e9960e21b8152600490fdfea2646970667358221220912a80cd02e3a7ea73e559d2d1294b316070896b0223612f54139d8f17e35fa464736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "fund(uint256,uint256)": {
        "params": {
          "amount": "uint256 Amount of reward tokens to deposit",
          "duration": "uint256 Duration over which to linearly unlock rewards"
        }
      },
      "owner()": {
        "details": "Returns the address of the current owner."
      },
      "rageQuit()": {
        "details": "This function should never revert when correctly called by the vault.      A max number of stakes per vault is set with MAX_STAKES_PER_VAULT to      place an upper bound on the for loop in calculateTotalStakeUnits(). access control: only callable by the vault directly state machine:   - when vault exists on this Aludel   - when active stake from this vault   - any power state state scope:   - decrease _aludel.totalStake   - increase _aludel.lastUpdate   - modify _aludel.totalStakeUnits   - delete _vaults[vault] token transfer: none"
      },
      "registerBonusToken(address)": {
        "details": "use this function to enable distribution of any ERC20 held by the RewardPool contract access control: only admin state machine:   - can be called multiple times   - only online state scope:   - append to _bonusTokenSet token transfer: none",
        "params": {
          "bonusToken": "address The address of the bonus token"
        }
      },
      "registerVaultFactory(address)": {
        "details": "use this function to enable stakes to vaults coming from the specified      factory contract access control: only admin state machine:   - can be called multiple times   - not shutdown state scope:   - append to _vaultFactorySet token transfer: none",
        "params": {
          "factory": "address The address of the vault factory"
        }
      },
      "removeVaultFactory(address)": {
        "details": "use this function to disable new stakes to vaults coming from the specified      factory contract.      note: vaults with existing stakes from this factory are sill able to unstake access control: only admin state machine:   - can be called multiple times   - not shutdown state scope:   - remove from _vaultFactorySet token transfer: none",
        "params": {
          "factory": "address The address of the vault factory"
        }
      },
      "renounceOwnership()": {
        "details": "Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."
      },
      "rescueTokensFromRewardPool(address,address,uint256)": {
        "details": "use this function to rescue tokens from RewardPool contract      without distributing to stakers or triggering emergency shutdown access control: only admin state machine:   - can be called multiple times   - only online state scope: none token transfer: transfer requested token from RewardPool to recipient",
        "params": {
          "amount": "uint256 The amount of tokens to rescue",
          "recipient": "address The address of the recipient",
          "token": "address The address of the token to rescue"
        }
      },
      "stake(address,uint256,bytes)": {
        "params": {
          "amount": "uint256 The amount of staking tokens to stake",
          "permission": "bytes The signed lock permission for the universal vault",
          "vault": "address The address of the vault to stake from"
        }
      },
      "transferOwnership(address)": {
        "details": "Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."
      },
      "unstakeAndClaim(address,uint256[],uint256[],bytes)": {
        "details": "rewards can only be claimed when unstaking, thus reseting the reward multiplier access control: anyone with a valid permission state machine:   - when vault exists on this Aludel   - after stake from vault   - can be called multiple times while sufficient stake remains   - only online state scope:   - decrease _aludel.rewardSharesOutstanding   - decrease _aludel.totalStake   - increase _aludel.lastUpdate   - modify _aludel.totalStakeUnits   - modify _vaults[vault].stakes   - decrease _vaults[vault].totalStake token transfer:   - transfer reward tokens from reward pool to vault   - transfer bonus tokens from reward pool to vault",
        "params": {
          "amounts": "uint256 The amount of staking tokens to unstake",
          "indices": "uint256 The amount of staking tokens to unstake",
          "permission": "bytes The signed lock permission for the universal vault",
          "vault": "address The vault to unstake from"
        }
      }
    },
    "title": "Aludel",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "fund(uint256,uint256)": {
        "notice": "Add funds to the Aludel access control: only admin state machine:   - can be called multiple times   - only online state scope:   - increase _aludel.rewardSharesOutstanding   - append to _aludel.rewardSchedules token transfer: transfer staking tokens from msg.sender to reward pool"
      },
      "initialize(uint64,address,address,uint16,bytes)": {
        "notice": "Initizalize Aludel access control: only proxy constructor state machine: can only be called once state scope: set initialization variables token transfer: none"
      },
      "rageQuit()": {
        "notice": "Exit Aludel without claiming reward"
      },
      "registerBonusToken(address)": {
        "notice": "Register bonus token for distribution"
      },
      "registerVaultFactory(address)": {
        "notice": "Add vault factory to whitelist"
      },
      "removeVaultFactory(address)": {
        "notice": "Remove vault factory from whitelist"
      },
      "rescueTokensFromRewardPool(address,address,uint256)": {
        "notice": "Rescue tokens from RewardPool"
      },
      "stake(address,uint256,bytes)": {
        "notice": "Stake tokens access control: anyone with a valid permission state machine:   - can be called multiple times   - only online   - when vault exists on this Aludel state scope:   - append to _vaults[vault].stakes   - increase _vaults[vault].totalStake   - increase _aludel.totalStake   - increase _aludel.totalStakeUnits   - increase _aludel.lastUpdate token transfer: transfer staking tokens from msg.sender to vault"
      },
      "unstakeAndClaim(address,uint256[],uint256[],bytes)": {
        "notice": "Unstake staking tokens and claim reward"
      }
    },
    "notice": "Reward distribution contract with time multiplier Access Control - Power controller:     Can power off / shutdown the Aludel     Can withdraw rewards from reward pool once shutdown - Aludel admin:     Can add funds to the Aludel, register bonus tokens, and whitelist new vault factories     Is a subset of proxy owner permissions - User:     Can deposit / withdraw / ragequit Aludel State Machine - Online:     Aludel is operating normally, all functions are enabled - Offline:     Aludel is temporarely disabled for maintenance     User deposits and withdrawls are disabled, ragequit remains enabled     Users can withdraw their stake through rageQuit() but forego their pending reward     Should only be used when downtime required for an upgrade - Shutdown:     Aludel is permanently disabled     All functions are disabled with the exception of ragequit     Users can withdraw their stake through rageQuit()     Power controller can withdraw from the reward pool     Should only be used if Proxy Owner role is compromized",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_owner",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 111,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_initialized",
        "offset": 20,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 114,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_initializing",
        "offset": 21,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 17116,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_powerSwitch",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 14489,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_aludel",
        "offset": 0,
        "slot": "2",
        "type": "t_struct(AludelData)16462_storage"
      },
      {
        "astId": 14494,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_vaults",
        "offset": 0,
        "slot": "14",
        "type": "t_mapping(t_address,t_struct(VaultData)16476_storage)"
      },
      {
        "astId": 14497,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_bonusTokenSet",
        "offset": 0,
        "slot": "15",
        "type": "t_struct(AddressSet)2003_storage"
      },
      {
        "astId": 14500,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_vaultFactorySet",
        "offset": 0,
        "slot": "17",
        "type": "t_struct(AddressSet)2003_storage"
      },
      {
        "astId": 14502,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_feeRecipient",
        "offset": 0,
        "slot": "19",
        "type": "t_address"
      },
      {
        "astId": 14504,
        "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
        "label": "_feeBps",
        "offset": 20,
        "slot": "19",
        "type": "t_uint16"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(RewardSchedule)16469_storage)dyn_storage": {
        "base": "t_struct(RewardSchedule)16469_storage",
        "encoding": "dynamic_array",
        "label": "struct IAludelV3.RewardSchedule[]",
        "numberOfBytes": "32"
      },
      "t_array(t_struct(StakeData)16481_storage)dyn_storage": {
        "base": "t_struct(StakeData)16481_storage",
        "encoding": "dynamic_array",
        "label": "struct IAludelV3.StakeData[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IAludelHooks)16382": {
        "encoding": "inplace",
        "label": "contract IAludelHooks",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_struct(VaultData)16476_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct IAludelV3.VaultData)",
        "numberOfBytes": "32",
        "value": "t_struct(VaultData)16476_storage"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_struct(AddressSet)2003_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.AddressSet",
        "members": [
          {
            "astId": 2002,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "_inner",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Set)1702_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(AludelData)16462_storage": {
        "encoding": "inplace",
        "label": "struct IAludelV3.AludelData",
        "members": [
          {
            "astId": 16439,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "stakingToken",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 16441,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "rewardToken",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 16443,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "rewardPool",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 16446,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "rewardScaling",
            "offset": 0,
            "slot": "3",
            "type": "t_struct(RewardScaling)16488_storage"
          },
          {
            "astId": 16448,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "rewardSharesOutstanding",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 16450,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "totalStake",
            "offset": 0,
            "slot": "7",
            "type": "t_uint256"
          },
          {
            "astId": 16452,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "totalStakeUnits",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 16454,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "lastUpdate",
            "offset": 0,
            "slot": "9",
            "type": "t_uint256"
          },
          {
            "astId": 16457,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "hookContract",
            "offset": 0,
            "slot": "10",
            "type": "t_contract(IAludelHooks)16382"
          },
          {
            "astId": 16461,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "rewardSchedules",
            "offset": 0,
            "slot": "11",
            "type": "t_array(t_struct(RewardSchedule)16469_storage)dyn_storage"
          }
        ],
        "numberOfBytes": "384"
      },
      "t_struct(RewardScaling)16488_storage": {
        "encoding": "inplace",
        "label": "struct IAludelV3.RewardScaling",
        "members": [
          {
            "astId": 16483,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "floor",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 16485,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "ceiling",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 16487,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "time",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(RewardSchedule)16469_storage": {
        "encoding": "inplace",
        "label": "struct IAludelV3.RewardSchedule",
        "members": [
          {
            "astId": 16464,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "duration",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 16466,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "start",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 16468,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "shares",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_struct(Set)1702_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.Set",
        "members": [
          {
            "astId": 1697,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "_values",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_bytes32)dyn_storage"
          },
          {
            "astId": 1701,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "_indexes",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_bytes32,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(StakeData)16481_storage": {
        "encoding": "inplace",
        "label": "struct IAludelV3.StakeData",
        "members": [
          {
            "astId": 16478,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "amount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 16480,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "timestamp",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(VaultData)16476_storage": {
        "encoding": "inplace",
        "label": "struct IAludelV3.VaultData",
        "members": [
          {
            "astId": 16471,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "totalStake",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 16475,
            "contract": "src/contracts/aludel/AludelV3.sol:AludelV3",
            "label": "stakes",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_struct(StakeData)16481_storage)dyn_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}